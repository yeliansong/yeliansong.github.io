[{"categories":["cat2"],"content":"新建 ","date":"2021-03-27 22:10:38","objectID":"https://zz2summer.github.io/test3/:0:0","tags":["tag1","tag3"],"title":"Test3","uri":"https://zz2summer.github.io/test3/"},{"categories":["cat1"],"content":"新建 ","date":"2021-03-27 21:56:51","objectID":"https://zz2summer.github.io/test1/:0:0","tags":["tag1","tag2"],"title":"Test1","uri":"https://zz2summer.github.io/test1/"},{"categories":[],"content":"新建 ","date":"2021-03-27 21:56:20","objectID":"https://zz2summer.github.io/about/:0:0","tags":[],"title":"About","uri":"https://zz2summer.github.io/about/"},{"categories":null,"content":"1. Downward API传递元数据 说实话，这章看的也是云里雾里的，感觉和环境变量配置差不多。我的理解是，Downward API 是用来给POD或容器的元数据进行配置，环境变量呢，是用来定义一些常规的变量参数。Downward API支持环境变量和文件两种方式，更加灵活。 ","date":"2019-09-16 00:00:00","objectID":"https://zz2summer.github.io/2019-09-16-8-%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/:0:1","tags":["读书笔记","tech","k8s"],"title":"八：从应用访问POD元数据及其他资源","uri":"https://zz2summer.github.io/2019-09-16-8-%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/"},{"categories":null,"content":"2. Kubernetes API 服务器交互 其实这一节主要就是讲，怎么使用Kubernetes 的API 。使用API其实就是访问它的服务器。每一层目录就是一级资源。 这个是通过ambassador 容器方式来访问API服务器。当然，也可以通过客户端的方式来访问API服务器。这一章内容主要是来配置POD的元数据，同时通过API方式来访问资源。 ","date":"2019-09-16 00:00:00","objectID":"https://zz2summer.github.io/2019-09-16-8-%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/:0:2","tags":["读书笔记","tech","k8s"],"title":"八：从应用访问POD元数据及其他资源","uri":"https://zz2summer.github.io/2019-09-16-8-%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/"},{"categories":null,"content":"1. 升级的几种方式 先来看一个案例，这种情况怎么处理： POD现在用的是V1版本，现在有一个V2版本，怎么把V2版本替换到V1版本？有三种方式： 删除旧版本POD，是用新版本POD替换 这种方法比较暴力，就是直接修改V1的配置模板为V2，然后删除V1的POD，这个时候V2的模板会检测，没有POD，会重新启动V2 版本的POD。这种方法会有一个问题，删除V1时整个服务会停止。 蓝绿部署 这个是这样的，就是你的程序同时支持V1，V2 版本，同时你的环境资源充分，可以同时运行这两个， 怎么做呢？ 就是在你的环境里把V2的POD启动起来，待所有的完全都没问题后，可以删除掉V1的POD，把服务的流量切换到V2。 这种方式的问题就是资源开销较大。 滚动升级 这个就比较厉害了，它是利用扩容和缩容来实现动态替换升级。 啥意思呢，就是在你的部署文件中定义新旧版本的POD，然后依次删除V1的POD， 使V2 的POD动态扩容。但是这种方式，如果用命令来操作比较繁琐。 ","date":"2019-09-16 00:00:00","objectID":"https://zz2summer.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/:0:1","tags":["读书笔记","tech","k8s"],"title":"九：Deployment声明式升级应用","uri":"https://zz2summer.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"2. 使用ReplicationController 实现自动滚动升级 使用kubectl 命令方式进行滚动升级。kubectl rolling-update kubia-v1 kubia-v2 –image=luksa/kubia:v2 命令。 这个命令到底干了啥呢，来看看。 可以看看这个图，是通过修改Replicas的数量来慢慢替换V1 的POD为V2。 但是这种方式有个问题，因为是用的Kubectl方式来完成这些，相当于是客户端方式，所以，如果没有网络时，可能会导致升级停止。 ","date":"2019-09-16 00:00:00","objectID":"https://zz2summer.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/:0:2","tags":["读书笔记","tech","k8s"],"title":"九：Deployment声明式升级应用","uri":"https://zz2summer.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"3. 使用Deployment升级应用 Deployment 是一种更加高级的升级方式，它是属于上层的一种升级方式，而另外几种是属于底层的。 使用Deployment时，实际是用的ReplicaSet来管理POD。所以到底是怎么做到滚动升级的呢。 Deployment 就是一个部署文件，可以在里面定义你要部署的信息，然后进行部署。 定义了一个部署，现在来看看如何来实现滚动升级。首先要触发升级，怎么触发呢，通过修改Deployment 文件的方式来触发。可以用Kubectl set image deployment kubia nodejs=luksa/kubia:v2 来重新指定镜像，POD就会重新去下载镜像。 然后在内部，它会依次去删除掉V1 的POD，然后再启动V2的POD。 它也可以自己定义升级的策略，RollinUpdate和Recreate两种，默认是第一种。 ","date":"2019-09-16 00:00:00","objectID":"https://zz2summer.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/:0:3","tags":["读书笔记","tech","k8s"],"title":"九：Deployment声明式升级应用","uri":"https://zz2summer.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"4. 回滚升级 现在有一个问题啊，假如你要升级一个V3版本，但是呢，V3 版本有一些bug,你升级了，然后发现有问题了，怎么回退到之前的版本呢？可以用命令方式解决：kubectl rollout undo deployment kubia， 可以回滚到上一个版本。也可以回退到某一个历史版本，可以先查看历史：kubectl rollout history deployment kubia 看所有的历史版本， 然后用kubectl rollout undo deployment kubia –to-revision = ? 来回退到某一个版本。 ","date":"2019-09-16 00:00:00","objectID":"https://zz2summer.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/:0:4","tags":["读书笔记","tech","k8s"],"title":"九：Deployment声明式升级应用","uri":"https://zz2summer.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"5. 滚动升级的状态控制 控制升级速率 用两个参数来定义：maxSurge 和 maxUnavailable ， 具体怎么计算的我不太想搞清楚了，可以看看作用。 暂停滚动升级 这个可以用来玩金丝雀升级。啥叫金丝雀，就是被束缚的。怎么玩呢，就是先来搞个滚动升级，然后立即暂停滚动升级，这个时候新的POD会被创建，旧的POD还在运行，而流量会有一部分切换到新的POD中，然后测试，测试通过后，你可以恢复滚动升级，完成替换，如果测试没有通过，可以回滚到之前版本。金丝雀升级其实就是让一些人来体验新版本。看看命令： kubectl rollout pause deployment kubia kubectl rollout resume deployment kubia 阻止出错版本的滚动升级 还有一个比较好的方式，就是可以设置一个时间段，和设置探针，在这个时间段呢，如果新的POD没有问题，则就支持滚动升级。这个相当于设置了一个保险，可以将风险降到最低。 为滚动升级配置的deadline 就是设置一个时间段，如果程序没有升级成功，就可以取消升级。 ","date":"2019-09-16 00:00:00","objectID":"https://zz2summer.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/:0:5","tags":["读书笔记","tech","k8s"],"title":"九：Deployment声明式升级应用","uri":"https://zz2summer.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"1. 容器命令行参数的配置 Docker 使用命令行参数是通过在Dockerfile 中定义Entrypoint 和CMD来实现，但是有个问题啊，这个是打包到镜像里的。先来看看这两个的区别吧。 Entrypoint: 定义容器启动时被调用的可执行程序。 CMD：指定传递给Entrypoint 的参数。 所以常规做法还是定义这两个，用命令行启动时，可以通过命令行的argu来覆盖file中的CMD的定义。当然了还有一种方式，就是脚本方式，可以将命令写入到脚本中，然后在dockerfile中定义调用这个脚本。 POD 中定义的命令可以覆盖容器的命令行。所以可以通过POD的YAML文件中的argu将参数传递给容器。 ","date":"2019-09-13 00:00:00","objectID":"https://zz2summer.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:1","tags":["读书笔记","tech","k8s"],"title":"七：ConfigMap 和 Secret配置应用程序","uri":"https://zz2summer.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"2. POD 环境变量的常规操作 在引出ConfigMap 之前，来看看POD配置环境变量的常规操作。其实你要明白，环境变量是给容器用的，所以呢一种思路就是这样的，在容器中定义好环境变量，容器里的程序引用环境变量，然后在POD的配置文件中对环境变量进行赋值，这就是常规操作。 就像这样的，定义了一个环境变量，然后呢，在POD中对这个变量进行赋值。这个方法呢，怎么样，好吗？显然是不好的，没有解耦，就是环境变量和POD的配置文件强相关了，所以有没好的方法可以实现解耦呢，就是这个配置文件不仅在这里可以用，在其他地方也可以用。这就使用ConfigMap 了。 ","date":"2019-09-13 00:00:00","objectID":"https://zz2summer.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:2","tags":["读书笔记","tech","k8s"],"title":"七：ConfigMap 和 Secret配置应用程序","uri":"https://zz2summer.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"3. ConfigMap 先要理解它要解决的问题，其实就是相当于一个独立的配置文件，然后可以在不同的环境里来引用它。所以这个东西还是蛮好的。创建ConfigMap可以通过命令方式或者YAML文件。不详细讲怎么创建了。 这个例子是，利用POD对容器中的环境变量INTERVAL进行重写。基本过程就是这样的： 不解释了，清楚明了。 但是有个问题啊，如果这个配置文件不存在怎么办，这个POD还能起来吗，答案是否定的。它会一直等存在这个配置文件后，容器才能启动。当然，你也可以设置参数，使其如果没有配置文件也能启动POD。 当然如果你的config file包含很多的key-value，一个一个设置，麻烦，可以一步到位。 prefix 是用来设置前缀的，还有一个，在配置文件中设置的key-value一定要按照格式来，不然的话，Kubernetes 不能解析。 ","date":"2019-09-13 00:00:00","objectID":"https://zz2summer.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:3","tags":["读书笔记","tech","k8s"],"title":"七：ConfigMap 和 Secret配置应用程序","uri":"https://zz2summer.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"4. secert 配置文件 当然，配置文件不能都是名文，对于需要进行加密的需要用secert方式进行配置。secert 和configMap一样也是key - value 方式，但是还是有一些区别，secert 是存在于POD的内存中，所以当删除POD时，就没有了这个配置。 ","date":"2019-09-13 00:00:00","objectID":"https://zz2summer.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:4","tags":["读书笔记","tech","k8s"],"title":"七：ConfigMap 和 Secret配置应用程序","uri":"https://zz2summer.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"1. 卷（volume） 终于等到你了，卷，volume。 也是kubernetes很重要的一个组件啊。不对，应该不能说是k8s的一个组件，应该说是属于POD中的一个组成部分。 卷是用来解决什么问题呢？POD其实相当于一个逻辑主机，每个POD可能有多个容器，这些容器呢，我们知道其实就相当于逻辑主机的进程，这些进程可以共享CPU，RAM，网络等，但是呢，每个容器是由自己的文件系统的，这些系统是相互隔离的，有没办法让这些容器共享文件系统呢？你想这个场景，比如POD里的一个容器挂了，然后重新起一个，但是起的这个呢依旧用之前那个的文件系统资源，怎么解决这个问题，你必须要用卷吗，相当于用共享的这个文件系统。 看这个，一个POD里面跑了三个容器，每个都是独立的文件系统，你说这个能跑起来吗？我来介绍下这三个容器，webserver， 就是web的入口，content用来放网页信息，log来存放日志，这三个没有共享文件系统，访问时web容器都找不到网页，日志也存放不了。来，看看改进版本。 共享卷之后，哈哈哈，能跑了，爽不爽。 ","date":"2019-09-12 00:00:00","objectID":"https://zz2summer.github.io/2019-09-12-6-%E5%8D%B7-%E5%B0%86%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8/:0:1","tags":["读书笔记","tech","k8s"],"title":"六：卷-将磁盘挂载到容器","uri":"https://zz2summer.github.io/2019-09-12-6-%E5%8D%B7-%E5%B0%86%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"2. 卷的几种类型 卷其实还是一种存储介质，它用的是宿主机，也就是POD主机的存储媒介。所以卷的性能是受逻辑主机影响的，当然也可以设置卷用memory的存储。根据使用习惯呢，卷也有很多类型。介绍两种： emptyDir 也是最简单的卷类型了，也是其他卷的基础，很好理解了，就是空卷。它的生命周期是和POD的生命周期一致的。这个是在POD启动时，会初始化一块空白的空间来存储内容。 这个就是例子了，每一个image可以设置卷的路径，然后在volume节点上可以设置卷的类型。 这个可以定义是用内存还是用的存储媒介。 Git存储卷 这个卷也是特别有意思，就是为git仓库设计的， 这个就是模型图了，POD启动时，会把远程的git 仓库拉到这个volume中，但是这个是不能实时同步的，也理解了，不会有这么先进的。 GIT 卷的原形是empty 卷，所以，生命周期也是和POD保持一致。 HostPath 卷 POD 之间能否共享文件呢，能的，这就是HostPath 卷。 你看这个图，两个POD 共享这个HostPath卷，所以即使你删除一个POD也不会对这个卷有影响。但是有一个问题，这个卷是和POD强相关的，就是如果你用其他的POD，就不能访问这个卷了。 持久卷 这一部分是很不同的环境相配合的，如果你用的是GCP，则有相应的组件支持，其他的云平台，也有其他的相应组件。所以这部分也不讲了，要弄清楚它的使用场景，这个是需要对数据进行持久化的，就是可以跨不同的节点进行数据访问。后续有用到可以着重看看。 ","date":"2019-09-12 00:00:00","objectID":"https://zz2summer.github.io/2019-09-12-6-%E5%8D%B7-%E5%B0%86%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8/:0:2","tags":["读书笔记","tech","k8s"],"title":"六：卷-将磁盘挂载到容器","uri":"https://zz2summer.github.io/2019-09-12-6-%E5%8D%B7-%E5%B0%86%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"1. 服务与端口 服务其实很好理解了，你想想看，一组相同的POD，你怎么管理，你需要知道他们的所有IP吗，然后再去一一进行手动配置连接？显然不需要的，怎么解决这个问题呢，就用服务，服务其实就是相当于一个路由的功能。 看看这个，前端有3个POD，还有一个Backend，怎么使整个系统正常运行呢，使用服务。三个前端设置一个前端服务，暴露一个IP，Backend也一样，暴露一个服务，所以每一部分的连接就只关注这个服务IP，而不用管每个POD的网络信息了。 这个是创建服务的YAML，KIND是一个Service， 然后将POD的端口进行映射，还有一个标签选择器。可以用kubectl expose 或 kubectl create 来创建服务。 这个好玩吗， 就是通过服务的方式来测试是否可以访问POD。就是先exec到一个POD中，然后通过curl方式来访问这个服务的ip，看能否连接到其他的POD。 很简单了。 来说说端口，一个POD可以有一个端口，也可以有多个端口，好理解了。 ","date":"2019-09-11 00:00:00","objectID":"https://zz2summer.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/:0:1","tags":["读书笔记","tech","k8s"],"title":"五：POD的服务与通信","uri":"https://zz2summer.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"2. 服务发现 其实就是用环境变量的方式来连接这个服务，而不是用固定IP的方式，毕竟IP可能会有变化。 可以选择一个POD，然后kubectl exec kubia-3inly env 来列出环境变量，然后查看这个服务的环境变量，通过变量的方式供给其他客户端连接。 ","date":"2019-09-11 00:00:00","objectID":"https://zz2summer.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/:0:2","tags":["读书笔记","tech","k8s"],"title":"五：POD的服务与通信","uri":"https://zz2summer.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"3. Endpoint 这家伙比较有意思了。看图吧。 很清晰明了，相当于把服务映射到了两个Endpoint中，可以理解为是负载均衡吗，有点像。 ","date":"2019-09-11 00:00:00","objectID":"https://zz2summer.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/:0:3","tags":["读书笔记","tech","k8s"],"title":"五：POD的服务与通信","uri":"https://zz2summer.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"4. 服务暴露给外部客户端的方法 记住了，三种方法。 NodePort 不知道这个设置的意义，啥意思呢，就是相当于给所有的节点预留了一个PORT，然后呢你有两种途径来访问它。第一种是clusterIp:端口，第二种是nodeIp：端口 有三个端口号，第一个是服务集群的端口，第二个是POD的目标端口，第三个是nodePort端口。这个图可以看到，30123是nodeport的端口，通过这个端口加node的IP可以访问节点。 负载均衡方式 它是从云基础架构中，搞一个外部IP，这个IP是独一无二的可公开访问的IP地址，通过这个再重定向到服务。其他的感觉没啥说的，看这个吧。 这个负载均衡器可以平均流量，看看它的策略。 ingress 一图看清它的功能： 啥意思呢，就是说可以通过域名的方式来选择性的访问服务。 这张图是看通过ingress方式来访问POD。 ","date":"2019-09-11 00:00:00","objectID":"https://zz2summer.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/:0:4","tags":["读书笔记","tech","k8s"],"title":"五：POD的服务与通信","uri":"https://zz2summer.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"5. 就绪探针 又他妈的一个神奇东西。真的是要处理各种情况，就绪探针是用来处理这种情况，就是你启动一个POD，不可能立即马上就起来吧，但是kube不知道啊，它可能还是会把流量可能给你啊，所以怎么避免这个问题呢，就用到了就绪指针，就是说，设置一个指针，成功或失败了都通知kube。 设置了一个就绪指针，就是在容器中执行ls命令，看文件存不存在。 ","date":"2019-09-11 00:00:00","objectID":"https://zz2summer.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/:0:5","tags":["读书笔记","tech","k8s"],"title":"五：POD的服务与通信","uri":"https://zz2summer.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2019-09-10 21:56:51","objectID":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/","tags":["K8S","微服务"],"title":"一：Kubernetes的介绍","uri":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"1. 单体应用和微服务的比较 单体应用的弊端：以单进程或几个进程的方式运行于几台服务器，部署的周期长，运维和开发脱节，开发人员完成开发后打包成一个整体给运维部署。 模块间没有解耦，修改一个模块，要把整体进行打包部署。 微服务的优势：模块间实现解耦，缩短部署周期，单个模块可以实现独立的开发，部署，升级，伸缩。缩短部署时间。还有节约资源，模块间可以单独 的进行扩容，而不用扩容所有。 ","date":"2019-09-10 21:56:51","objectID":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:1","tags":["K8S","微服务"],"title":"一：Kubernetes的介绍","uri":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"2. DevOps 微服务带来了DevOps。 以前的团队组合是，开发人员完成开发后把成果物给运维，然后运维完成部署，开发和运维是完全分开的。这就带来一个问题，开发人员不能第一时间了解用户的需求，而且也不了解系统的运行环境，而运维也不了解产品的功能。微服务来了后，通过kubernetes对系统硬件资源的虚拟化，使开发人员不用担心部署环境，简化系统的部署，开发人员也可以参与到部署中，也就衍生了DevOps。 ","date":"2019-09-10 21:56:51","objectID":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:2","tags":["K8S","微服务"],"title":"一：Kubernetes的介绍","uri":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"3. 容器技术 容器技术其实就是Linux的隔离技术。通过什么来进行隔离呢？ 命名空间和CGROUP。 命名空间是用来隔离不同的进程，CGROUP是用来隔离资源。就是通过这个能够使一个宿主机可以运行多个不同的应用程序。同一个宿主机上的两个应用程序也可以共享文件，如果共用同一个基本镜像，就是共用资源，但是 这一层文件是只读的，如果重写写入，是在基本镜像基础上写入一层文件，容器是用的联合文件系统。 ","date":"2019-09-10 21:56:51","objectID":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:3","tags":["K8S","微服务"],"title":"一：Kubernetes的介绍","uri":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"4. 容器的移植 容器的镜像是一个完整的系统，经过裁减后的。它裁减的还是宿主机的，所以一个容器镜像能否运行还是要看镜像所在运行的环境。如果编排镜像的宿主机环境的内核版本和运行环境一致，则可以运行。同时也要看是否用到宿主机特有的一些系统资源。 ","date":"2019-09-10 21:56:51","objectID":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:4","tags":["K8S","微服务"],"title":"一：Kubernetes的介绍","uri":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"5. Kubernetes Google搞出这个东西，是为了解决Google成千上万服务器的管理部署问题。之后容器技术火后，Kubernetes对容器的支持，所以说也可以说是Kubernetes成就了Docker。相符相承吧。Kubernetes的设计宗旨是将底层基础设施进行抽象化，通过给你提供一个主节点，来管理成千上万的你的服务的运行节点。你不用 关心你的服务运行节点的部署。 ","date":"2019-09-10 21:56:51","objectID":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:5","tags":["K8S","微服务"],"title":"一：Kubernetes的介绍","uri":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"6. Kubernetes 的组成 主节点： API服务器（功能入口，管理其他模块）， Schedule（调度应用）， Control Manager， etcd（分布式数据存储） 工作节点： kubelet (与API进行通信，管理容器)， kube-proxy(负责网络流量均衡) ","date":"2019-09-10 21:56:51","objectID":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:6","tags":["K8S","微服务"],"title":"一：Kubernetes的介绍","uri":"https://zz2summer.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"1. 理解Docker镜像,文件系统和容器 容器的镜像就是打包编译容器后的一个文件，打包镜像是依赖Dockerfile文件，From行定义了镜像的起始内容，也就是构建的基础镜像，镜像的构建过程是将整个目录的文件上传到Docker守护进程中，Docker会先从基础镜像仓库中拉取基础镜像，然后镜像的打包是一个分层的结构，基础镜像作为一层，然后每一条命令会作为一个新的分层，一层一层叠加，整个就是一个联合文件系统。 容器的理解， 容器其实就是镜像运行的一个实例。容器是依赖于主机的操作系统运行的，所以就会有一个问题，比如在RedHat宿主机上打包的一个镜像，这个镜像能否在ubuntu上运行呢？不一定，要看你是否有用到宿主机特有的， 但是你在另外一个宿主机上运行没有的东西。镜像运行出的容器，相当于宿主机的一个进程。每个容器间的文件系统也是独立的。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/:0:1","tags":["读书笔记","tech","k8s","docker"],"title":"二：Kubernetes 和 Docker的使用","uri":"https://zz2summer.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"2. Kubernetes 集群和Mini Kube 先来理解下集群的概念，什么是集群？ 集群就是将多个计算机节点组合到一起，形成一个群集，所以集群的优点也很明显，可以更好的管理系统，提供单机系统的性能。 看看mini kube, 它是本地的一个单节点的集群，它不适用于多节点的情况。要想和kubernetes交互，还需要kubernetes cli客户端。 多节点的Kubernetes集群概览： 三个节点的kubernetes图。看看这个玩意， 每一个工作节点都有Docker，Kubelet和Kube-proxy,可以通过kubectl通过rest向主节点发送控制命令，来控制每个分节点。有意思。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/:0:2","tags":["读书笔记","tech","k8s","docker"],"title":"二：Kubernetes 和 Docker的使用","uri":"https://zz2summer.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"3. ReplicationControler POD 是Kubernetes 控制的最小单位，Kubernetes不会关心容器的调度，它只会管POD。一个POD中可以有很多个container，但是这一组container是关联密切的，因为他们可以看作是运行在同一个宿主机上。So 什么是ReplicationControler呢，这玩意是用来干啥的。 我的理解阿，ReplicationControler 是用来管理POD的水平伸缩，能够确保规定的POD个数能按照设置的正常运行。 可以看下这张图，外部访问过来后，只会映射到一个内部ip，然后到底调用的哪个POD我们是不用关心的，里面的每个POD都是独立的ip。ReplicationControler来控制副本的个数。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/:0:3","tags":["读书笔记","tech","k8s","docker"],"title":"二：Kubernetes 和 Docker的使用","uri":"https://zz2summer.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"4. 梳理下kubectl一些相关的命令 kubectl get pods, 列出所有的POD， kubectl expose kubia –type=LoadBalancer –name kubia-http.将服务的网络设置为LoadBalancer方式，kubectl get service,列出所有的服务 kubectl get replicationcontrollers,列出所有的副本。kubectl scale rc kubia –replicas=3,将副本扩充。 kubectl get rc,查看扩容。kubectl get pods -o wide,查看POD的ip和运行的节点。kubectl describe pod,可以查看这个POD的日志信息。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/:0:4","tags":["读书笔记","tech","k8s","docker"],"title":"二：Kubernetes 和 Docker的使用","uri":"https://zz2summer.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"1. 为啥要搞出POD 我们知道，POD是Kubernetes管理的最小单位，为啥Kubernetes不直接管理container，要管理POD呢？这是有原因的，我们知道，container是单一进程的，啥意思呢，就是container的设计思想就是每个container只运行一个进程， 如果用枯bernetes直接去管理这些container，肯定是错综复杂，所以就搞出了POD这个东西，来实现容器间的资源和网络隔离，在同一个POD下的所有容器共享网络和系统资源，但是呢，一个POD内的所有容器肯定是逻辑业务密切结合的一个整体，他们肯定是有很强的联系。每一个container可以用端口来进行区分。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/:0:1","tags":["读书笔记","tech","k8s","docker"],"title":"三： 运行于Kubernetes中的容器","uri":"https://zz2summer.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"2. 怎么规划POD中的容器 刚说到，POD中放的是一组容器，怎么来规划这些容器呢，把项目中所有容器都放到一个POD中可以吗？因为POD比较轻量，所以鼓励是尽可能多的用POD，而规划POD中的容器，需要考虑的是，你的这一组容器的业务逻辑是否紧密相连，还有你是否要scale你的容器，这些是你的判断条件。 很好的一个例子，前端和后端分为两个POD来进行部署。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/:0:2","tags":["读书笔记","tech","k8s","docker"],"title":"三： 运行于Kubernetes中的容器","uri":"https://zz2summer.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"3. YAML文件分析及创建POD 非常的EASY， 其实一个YAML文件就包含：kind, metadata, spe这些东西。metadata 是用来定义POD的数据，spec是用来定义这个POD下的所有容器数据。 有几个命令需要学习下：Kubectl create -f a.yaml， 这个是通过yaml文件来创建需要的POD。获取POD中指定容器的日志信息，可以用kubectl logs kula -c kubia。获取运行的POD的yaml或json格式文件，可以用kubectl get po kubia -o yaml 或kubectl get po kubia -o json。kubectl port-forward kubela 8888:8080 用来搞端口映射。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/:0:3","tags":["读书笔记","tech","k8s","docker"],"title":"三： 运行于Kubernetes中的容器","uri":"https://zz2summer.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"4. POD的标签 标签的作用毋庸置疑，就是用来区分POD。所以加入标签这个就是为了能更好的管理你的POD。一个POD可以设置多个标签，然后利用标签来统一的调度POD。标签的一些命令可以通过手册查看，包括修改标签，设置标签，增加标签等等。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/:0:4","tags":["读书笔记","tech","k8s","docker"],"title":"三： 运行于Kubernetes中的容器","uri":"https://zz2summer.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"5. Namespace 先搞清楚，搞出Namespace的目的，我们知道，已经有了标签的概念了，标签也是可以用来分组，但是为啥还是要搞出Namespace呢？标签的分组还是不太彻底，一个POD可以有多个标签，所以我觉得标签还是更多的给运维人员用，搞出Namespace就不一样了，每一个POD只有唯一的一个Namespace，使资源的分组更加的彻底。 来看看怎么玩Namespace。 kubectl get ns: 列出所有的命名空间，kubectl get po –namespace kube-system:列出指定Namespace的所有POD。kubectl create namespace custom-namespace,创建一个Namespace。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/:0:5","tags":["读书笔记","tech","k8s","docker"],"title":"三： 运行于Kubernetes中的容器","uri":"https://zz2summer.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"1. 存活探针 为啥要搞出这么一个高深的词？我们知道POD里如果有容器程序崩溃了，kubenetes 会重新启动程序，但是问题来了，如果不是崩溃的情况呢，比如死锁了，或者抛了异常等等，这个时候咋整，kubenetes也不知道你的容器是否正常，这个时候就要用到探针了。其实道理很简单，就是用一个探针时不时地探测下，看是否正常。 三种探针：1）HTTP GET探针，就是用来检查网络是否正常。2）TCP套接字探针，也差不多，就是建立TCP连接，如果成功了就是正常的。3）Exec探针，就是在容器内执行任意命令，如果返回正常就是成功的。 探针其实也是一个POD，可以定义一些属性，用来控制探针的一些操作。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/:0:1","tags":["读书笔记","tech","k8s"],"title":"四：副本机制部署托管POD","uri":"https://zz2summer.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/"},{"categories":null,"content":"2. ReplicationController 也是一个很牛逼得东西，就是副本控制吧。就是用来保证POD的个数，可用来POD的水平扩展。 RC 有三个部分：label selector,标签选择器，用来确定RC作用域有哪些POD； RC COUNT：用来指定POD的数量； POD TEMP：模板，创建新POD副本。 来看看标签对RC的影响。其实也很好理解，RC只对它里面定义的标签负责，时刻监控着这些标签的POD个数，当这些标签的POD有减少或增加时，会动态调整。所以呢，两种情况，第一种，如果你修改了运行的POD里的标签，相当于这个POD以前是属于A，然后后面属于B了，这个时候RC要干事了，他会重新来创建POD。第二种情况，修改RC的标签，那这个标签里的POD全部脱离监控，全部都是自由的。 是用kubectl edit rc kubia 玩玩，你会发现，你可以修改当前的RC，然后修改当前的RC对现在运行的POD是没有任何影响的，只会对后面的POD有影响。 有点意思，三个POD，删除RC后，这3个POD不受影响，脱离了RC的束缚。 but， 不要用RC了，用ReplicaSet, 这哥们的功能和RC一样，但是功能增强了很多，主要是对标签的运用上更加灵活，其他的和RC完全一样，所以对这个也不要有压力了。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/:0:2","tags":["读书笔记","tech","k8s"],"title":"四：副本机制部署托管POD","uri":"https://zz2summer.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/"},{"categories":null,"content":"3. DaemonSet 这个又是用来干啥的呢，是用来控制POD的部署，意思就是按照自己的定义来部署POD。 来来来，看这货，左边是用的ReplicaSet，部署的POD在每个节点上是杂乱无章的，我现在要求每个节点只部署一个POD，这种情况怎么处理？这就要用到DaemonSet了。 这个时DaemonSet的YAML 文件，nodeSelector 节点调度器。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/:0:3","tags":["读书笔记","tech","k8s"],"title":"四：副本机制部署托管POD","uri":"https://zz2summer.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/"},{"categories":null,"content":"4. JOB 这个是用来定义一次任务，就是在完成后结束掉。而不是希望一直在运行它，这个也是一个很好的运用。JOB也有很多应用设置，可以设置任务的延迟时间等。 ","date":"2019-09-10 00:00:00","objectID":"https://zz2summer.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/:0:4","tags":["读书笔记","tech","k8s"],"title":"四：副本机制部署托管POD","uri":"https://zz2summer.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/"}]