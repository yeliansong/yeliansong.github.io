[{"categories":["技能证书"],"content":"证书荣誉","date":"2023-05-13 10:23:00","objectID":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/","tags":["腾讯云证书","技能证书"],"title":"腾讯云证书","uri":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"中文版本 ","date":"2023-05-13 10:23:00","objectID":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/:1:0","tags":["腾讯云证书","技能证书"],"title":"腾讯云证书","uri":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"腾讯云从业者证书 ","date":"2023-05-13 10:23:00","objectID":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/:1:1","tags":["腾讯云证书","技能证书"],"title":"腾讯云证书","uri":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"腾讯云运维工程师证书 ","date":"2023-05-13 10:23:00","objectID":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/:1:2","tags":["腾讯云证书","技能证书"],"title":"腾讯云证书","uri":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"腾讯云架构师工程师证书 ","date":"2023-05-13 10:23:00","objectID":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/:1:3","tags":["腾讯云证书","技能证书"],"title":"腾讯云证书","uri":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"English Version ","date":"2023-05-13 10:23:00","objectID":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/:2:0","tags":["腾讯云证书","技能证书"],"title":"腾讯云证书","uri":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"Tencent Cloud Practitioner ","date":"2023-05-13 10:23:00","objectID":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/:2:1","tags":["腾讯云证书","技能证书"],"title":"腾讯云证书","uri":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"Tencent Cloud SysOps Engineer ","date":"2023-05-13 10:23:00","objectID":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/:2:2","tags":["腾讯云证书","技能证书"],"title":"腾讯云证书","uri":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"Tencent Cloud Architect Engineer ","date":"2023-05-13 10:23:00","objectID":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/:2:3","tags":["腾讯云证书","技能证书"],"title":"腾讯云证书","uri":"https://yeliansong.github.io/2023-05-13-%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"CKA考试","date":"2023-02-17 09:31:00","objectID":"https://yeliansong.github.io/2023-2-17-cka%E6%8A%80%E8%83%BD%E8%AF%81%E4%B9%A6/","tags":["CKA考试","技能证书"],"title":"K8S 运维证书","uri":"https://yeliansong.github.io/2023-2-17-cka%E6%8A%80%E8%83%BD%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"1. Certified Kubernetes Administrator ","date":"2023-02-17 09:31:00","objectID":"https://yeliansong.github.io/2023-2-17-cka%E6%8A%80%E8%83%BD%E8%AF%81%E4%B9%A6/:0:1","tags":["CKA考试","技能证书"],"title":"K8S 运维证书","uri":"https://yeliansong.github.io/2023-2-17-cka%E6%8A%80%E8%83%BD%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"2. The Exam Info ","date":"2023-02-17 09:31:00","objectID":"https://yeliansong.github.io/2023-2-17-cka%E6%8A%80%E8%83%BD%E8%AF%81%E4%B9%A6/:0:2","tags":["CKA考试","技能证书"],"title":"K8S 运维证书","uri":"https://yeliansong.github.io/2023-2-17-cka%E6%8A%80%E8%83%BD%E8%AF%81%E4%B9%A6/"},{"categories":["技能证书"],"content":"3. Certification Verification Tool You can access this link to verify the certification. Certification Verification Tool ","date":"2023-02-17 09:31:00","objectID":"https://yeliansong.github.io/2023-2-17-cka%E6%8A%80%E8%83%BD%E8%AF%81%E4%B9%A6/:0:3","tags":["CKA考试","技能证书"],"title":"K8S 运维证书","uri":"https://yeliansong.github.io/2023-2-17-cka%E6%8A%80%E8%83%BD%E8%AF%81%E4%B9%A6/"},{"categories":["运维相关知识"],"content":"运维经验","date":"2023-02-04 09:14:00","objectID":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/","tags":["运维","操作系统"],"title":"浅谈 lsof 的一些使用","uri":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/"},{"categories":["运维相关知识"],"content":"1 Linux 一切皆文件 在Linux 系统中，一切皆文件。通过文件不仅可以查看存储到磁盘中的文件数据，还可以访问网络连接和硬件。问题来了，竟然一切皆是文件，那怎么通过命令方式查看及管理这些打开的文件呢。可以用lsof 命令。不仅可以查看进程打开的文件、目录，还可以查看进程监听的端口等socket 信息。 ","date":"2023-02-04 09:14:00","objectID":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/:0:1","tags":["运维","操作系统"],"title":"浅谈 lsof 的一些使用","uri":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/"},{"categories":["运维相关知识"],"content":"2 lsof 命令的常用选项 -a 指示其它选项之间为与的关系 -c \u003c进程名\u003e 输出指定进程所打开的文件 -d \u003c文件描述符\u003e 列出占用该文件号的进程 +d \u003c目录\u003e 输出目录及目录下被打开的文件和目录(不递归) +D \u003c目录\u003e 递归输出及目录下被打开的文件和目录 -i \u003c条件\u003e 输出符合条件与网络相关的文件 -n 不解析主机名 -p \u003c进程号\u003e 输出指定 PID 的进程所打开的文件 -P 不解析端口号 -t 只输出 PID -u 输出指定用户打开的文件 -U 输出打开的 UNIX domain socket 文件 -h 显示帮助信息 -v 显示版本信息 ","date":"2023-02-04 09:14:00","objectID":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/:0:2","tags":["运维","操作系统"],"title":"浅谈 lsof 的一些使用","uri":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/"},{"categories":["运维相关知识"],"content":"3 一些简单的应用 这里就不列举所有的应用场景了，可以根据具体的需要再去查找，需要记住的是，但凡涉及到文件相关的，都可以想到用lsof 命令。列一些简单的应用场景，加深下对命令的使用。 3.1 查看哪些进程打开了某个文件 这个应该是经常用到，在windowns 里比如想要关掉某个文件发现一直关不掉，原因是这个文件被很多进程同时使用了，想要把它关掉还关不掉，只能先把所有正在使用该文件的进程kill 掉才行，这时候可以用lsof 了。 +d 是针对于文件夹的操作，同时如果需要kill 掉所有的进程id，可以用awk 把pid 号列下来然后kill 掉。 3.2 查看某个进程打开的所有文件 这个有时候也需要用到，某个进程做了哪些操作，打开了哪些文件。 用lsof -p + pid 来查看这个进程打开了哪些文件。 3.3 查看ipv4、ipv6 打开的文件 网络相关的文件操作也是用的很多，所以对一些问题定位需要用lsof 来查看网络相关对文件的一些操作。lsof -i 是查看ipv4和v6 对文件的操作。 当然，如果需要单独看ipv4 或 ipv6，可以直接lsof -i ipv4/ipv6 来指定 $ sudo lsof -i 4 $ sudo lsof -i 6 3.4 列出与端口相关的文件 这个用的就比较多了，经常要查相关端口所使用的文件，比如说22 端口或啥的。用lsof -i:port. ","date":"2023-02-04 09:14:00","objectID":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/:0:3","tags":["运维","操作系统"],"title":"浅谈 lsof 的一些使用","uri":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/"},{"categories":["运维相关知识"],"content":"4 具体的一个practice 之前有遇到过一个案例，就是用df -h 和 du -sh /某个文件夹， 发现两个所显示的磁盘空间占用相差很大，原因是df -h 是统计的文件夹在磁盘中空间，包括这个文件夹可能被删除过或其他地方引用着，但du 是统计的是当前文件夹实际大小，所以可能是df -h 统计的某个文件夹是大于du -sh 的。我当时就遇到这种情况，而且两者相差还非常的大，怎么解决这个问题呢，可以用lsof ｜ grep delete 来查找这个文件夹被delete 进程所占用的，然后把这些进程都kill 掉。 ","date":"2023-02-04 09:14:00","objectID":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/:0:4","tags":["运维","操作系统"],"title":"浅谈 lsof 的一些使用","uri":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/"},{"categories":["运维相关知识"],"content":"5 小结 关于lsof 的一些使用主要的就说这么多，还有很多其他的一些用法，可以根据平常工作需要来定向查找。 可以参考： https://www.cnblogs.com/sparkdev/p/10271351.html ","date":"2023-02-04 09:14:00","objectID":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/:0:5","tags":["运维","操作系统"],"title":"浅谈 lsof 的一些使用","uri":"https://yeliansong.github.io/2022-8-10-%E6%B5%85%E8%B0%88lsof-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8/"},{"categories":["生活感悟"],"content":"日本旅游","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"1 出发前待办事情清单 20寸行李箱购买 登记前查询是否需要做核酸等 查询当地天气温度，备好衣物 出行前相关的日本必备的app 下载好 详细的旅游攻略，每天的行程安排 和老板请好假 酒店预定，定好酒店 疫苗接种 新加坡海关通行文件打印两份 打印疫苗证书及提交信息到日本入境政府网站 换钱 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:1:0","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"2 愿望清单 ❤️ 泡温泉 ❤️ 看小鹿 ❤️ 怀石料理、章鱼烧 ❤️ 感受下当地生活，晚上在日本街头悠闲逛逛 ❤️ 探究下历史，寺庙等，了解下当地文化这些 ❤️ 看枫叶 ❤️ 试日本清酒 ❤️ 体验民宿 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:2:0","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"3 当地温度 ☁️ 大阪：9-19摄氏度 ☁️ 京都：7-19摄氏度 ☁️ 奈良：7-19摄氏度 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:3:0","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"4 入境日本及新加坡入境要求 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:4:0","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"日本入境： 疫苗证书或阴性检测报告，出发前提交到日本政府网站。For Travelers to Japan (Entry/Re-Entry to Japan, Pre-departure test etc.) ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:4:1","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"新加坡入境： 疫苗接种证明及提交新加坡入境卡和电子健康申明 https://eservices.ica.gov.sg/sgarrivalcard/ ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:4:2","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"5 城市简介 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:5:0","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"京都： 概况 日本文化与大和之魂的真正所在，拥有众多幽静的古刹和神社，世界上最富文化气息的城市之一，千年古都。 3月-4月：春季，热闹樱花季 9月-11月：9月赏菊、赏彼岸花，10月中下旬著名的时代祭，红叶则在11月中旬开始渐入佳境 生活消费便宜，旅游消费较高的城市，住宿较贵，交通也挺贵。 景点 1）伏见稻荷大社：是稻荷神社的总本社，稻荷神是掌管仓稻的，狐狸被称为五谷神的使者。千本鸟居 2）清水寺：京都最古老的寺庙，赏枫胜地，音羽瀑布 3）金阁寺：聪明的一休. https://www.shokoku-ji.jp/zh/kinkakuji/ 4）岚山：集中了很多古刹和神社，天龙寺世界遗产级别的古迹，赏樱赏枫胜地，峨眉野小火车 5）三年坂二年坂：极具京都风情，各种小吃店、和风杂货店，京都买手信的好地方，清水寺旁 http://2nenzaka.ne.jp/zh/top-2/ 6）八坂神社： 二年坂三年坂旁，逛完后可以逛下这个，心形绘马，祈求姻缘 7）邸园：京都繁华的街区，舞伎和艺伎出没，夜生活的好去处 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:5:1","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"奈良： 概况：历史比千年古都京都更为悠久，日本文明的发源地，招牌是小鹿 景点： 1）奈良公园：囊括包藏诸多贵重历史文化遗产的东大寺、兴福寺、春日大社等建筑。喂食萌萌的小鹿 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:5:2","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"大阪： 概况：繁华程度仅次于东京的日本主要城市，紧临京都和奈良，关西路线重要一站。美食和购物胜地，消费水平比国内一线城市略高，但比东京低。 景点： 1）大阪城公园：日本三大名城之一，眺望大阪市内风景，天守阁 2）四大天王寺：日本最古老的建筑群落之一，保持着最初建筑时的格局和部分建筑构造 3）通天阁：高塔观景台，地标之一。可前往3层的hello kitty主题世界以及2层的pocky 王国 4）道顿崛\u0026心斋桥：大阪市中心，美食街 5）天宝山摩天轮：日本最高的摩天轮，晚上可看日本的夜景 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:5:3","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"6 具体行程安排 ​ 11月6号 8:30am SIN — 大阪关西机场 15:40 ​ 11月14号 18:30 大阪关西机场 —— 00:30am SIN Day1: 时间：11月6号 到达关西机场，过安检，需要提前出示行程码，就是你的个人旅行信息，强烈建议在起飞前做好，毕竟下飞机后没网情况下又语言不同很慌乱 领免费的wamazing sim卡，这个是个免费福利，在出发前可以下载wamazing app免费注册后，会提示你到达机场指定地方去领取sim 卡，包含500M 免费流量，这个流量对于刚来日本没有电话卡情况下还是很关键的。 买icoca卡。出来关西机场，到对面的地铁站机器上买一张icoca卡，坐地铁巴士都可以直接用 关西机场坐Haruka JR线大概80分钟到kyoto站 Day2: 时间：11月7号 住的地方是靠近kyoto站，这个地方Kyoto Prefecture 600-8258, Japan 民宿 上午东寺，大概2小时 中午京都野菜馆自助餐，超级便宜，只要1100日币 下午伏见稻荷大社，大概2.5小时 东福寺，大概2小时 三十三间堂，大概1小时 晚上锦市场吃吃喝喝，其实可以不去，因为第二天我就住在附近，可以替换成去鸭川逛逛 Day3: 时间：11月8号 搬行李从民宿转移到酒店，酒店是在二条城附近 上午清水寺，大概3小时 沿着走下来到三年坂二年坂，大概2小时，中间有很多吃的，可以选择性的吃吃喝喝 八坂神社 邸园附近都可以逛 下午有时间可以再逛逛京都博物馆、二条御所等等 晚上住的酒店附近吃的巨多 Day4: 时间：11月9号 全天时间在岚山上，野宫神社、天龙寺、渡月桥，岚山峨眉野小火车提前预约买票，看枫叶 空位狀況| 嵯峨野觀光鐵道 去现场买票，买5号车厢透明车窗的，前一天看看票的情况，如果不够了就在网上买。 可以从嵯峨野坐到龟岗。到了后周边也没什么好逛的，直接再坐地铁到嵯峨野站，可以沿着一路到天龙寺、竹林、野宫神社、渡月桥、岚山公园。在岚山公园里有一个风风之汤温泉，可以体验下。渡月桥那地方相当不错，可以花点时间在周边玩。 Day5: 时间：11月10号 打包好行李，放在酒店寄存，可以利用上午时间再逛逛。 金阁寺、银阁寺 回到酒店附近，吃点东西，准备出发去奈良 Day6: 时间：11月11号 要重点夸奖下定的地方很好，在奈良公园里面，去周边的景点都非常方便。 早上奈良公园拍小鹿 逛东大寺、一路到春日大社、再到依水园、中午吃点东西，下午再逛回到奈良公园 Day7: 时间：11月12号 上午从奈良返回大阪，空庭温泉搞起下午，可以考虑在温泉处睡觉，第二天 https://solaniwa.com/zh-cn/explore/inemuri/ Day8: 时间：11月13号 游览四大天王寺、天通阁、新世界，大阪海游馆，晚上坐摩天轮 Day9: 时间：11月14号 最后一天，可以考虑购物，整理东西，准备返程 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:6:0","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"7 日本交通 日本交通发达，拥有密集的铁路、地铁、公路系统以及便捷的飞机、轮渡。城市间主要是铁路，市内交通主要地下铁和公交。 铁路系统分为JR和地方私营铁路。长途旅程用JR铁路居多，单一或邻近区域用似铁较多。 JR： Japan Railway缩写，按区域由JR北海道、JR东日本、JR东海、JR西日本、JR四国以及JR九州等6家公司运营。按列车速度划分为：新干线、特急、急行、快速和普通。 私铁： 由私企修建的铁路，主要任务是大城市与近邻间的通勤。 交通卡选择： 东京的suica 和 关西地区的icoca。各城市、地区都有专属的优惠套票。 关西机场到京都：JR 特急HARUKA 号， ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:7:0","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"8 酒店 11月6号 - 11月8号 Log In / Sign Up Hisashi WhatsApp +817026721372 LINE 0753710393 WeChat yamayama8975 11月8号 - 11月10号 11月10号 —— 11月12号 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:8:0","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"9 其他 大阪游玩： ​ 大阪周游券，两天或一天的 ​ 买两天，买vista osaka 便宜100 ​ 其他40几个景点都免费 ​ 还有 一些店铺折扣 ​ osaka metro 购买 ​ 道顿掘水上观光船 ​ wonder cruise ​ 帆船型游船 圣玛利亚号 黄昏游览 ​ 大川樱花游览船 白天 ​ 大阪城御座船 ​ 空中庭院瞭望台 梅天蓝天大厦 ​ 天空美术馆 ​ 天保山摩天轮 ​ 天守阁 ​ 通天阁 ​ 四天王寺 ​ osaka wheel ​ 圣马里亚号 + 天保山摩天轮 下午三点到换票 ​ 中之岛水上观光船 + 四天王寺 + 大阪城公园一起 ​ 道顿掘水上观光船 11 点 ​ 可以安排在一起 早上到了后 ​ 梅田蓝天大厦 展望台 九点半 ​ 天空美术馆 ​ ninja trick house 享受优惠 要买的东西： ​ 城野医生 ​ 雅萌 ​ 酒 ​ 洗衣服清香的 那个柔顺剂 ​ ebisu 牙刷 ​ strong wakamoto 消化酵素 ​ the public organic 唇膏 ​ 香氛 ​ 狮王牙膏 ​ 无比滴 ","date":"2022-12-04 09:14:00","objectID":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/:9:0","tags":["旅游、生活感悟"],"title":"日本旅游计划 (2022.11-6——2022.11-14）","uri":"https://yeliansong.github.io/2022-12-04-%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/"},{"categories":["生活感悟"],"content":"读书感悟","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"1 引言 最近看完了刘慈欣老师的《三体》，零零总总花了四十几个小时，前前后后大半个月时间，直到今天看完还一直沉浸中三体的世界里，除了震撼还是震撼。我很少看科幻题材的书和电影，主要是感觉太脱离实际了，想象力太天马行空，完全跟不上剧情节奏，但三体我是真的深深爱上了，虽然是长篇科幻小说，但整个故事情节是在现实基础上展开的构思，剧情也没完全脱离现实，对人物的塑造以及人性的剖析让整本书看起来又不像仅仅是一本科幻类书籍。总之，绝对是值得一读的一本书，无论你是否是一名科幻迷。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:1","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"2 《三体》及刘慈欣老师 《三体》总共是三部：地球往事、黑暗森林、死神永生。剧情可以简单概括为地球文明和地外太空的三体文明间的争夺以及宇宙的终极毁灭的故事，其中穿插着红岸基地向外太空广播信息、三体人回复、三体人派舰队攻占地球、危机纪元的面壁者计划、水滴对太空战舰的降维打击、逻辑的黑暗森林法则、执剑者计划、三体文明坐标的暴露、地球掩体计划、太阳系的覆灭以及逃出太阳系的地球文明的延续。整个故事情节一气呵成，看的直呼过瘾。 在这不得不提刘慈欣老师的非人般的想象力，刘慈欣老师创作《三体》时是山西阳泉市一家电厂担任计算机工程师，很难想象，在这么一个小城市，一家电厂的职员能有如此浩瀚宇宙的想象力，网上的一些段子说大刘是摸鱼鼻祖，哈哈哈，确实是的啊，在上班期间创作这么优秀的作品确实是把摸鱼做到了极致，大刘的《三体》也是开创了中国科幻作品的先河，让中国的科幻在世界的舞台上有一席之地。有一个小故事，当年时任美国总统的奥巴马看完《三体》的前两部后感觉意犹未尽，催促大刘赶紧出第三部，有点催更的感觉，也能看出《三体》的超强吸引力。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:2","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"3 《三体》之外的故事 – 人类探索外太空的一些历史 之前我一直都有一个困扰，为啥一些发达国家包括中国要大力发展航空航天，比如时不时一些探月计划、火星计划、卫星火箭的发射等。这些都是非常劳命伤财的，用这些钱去建设小康社会不好吗？毕竟还有很多地方还没脱贫，或者去建设保护我们自己的居住环境-地球不好吗？读者在这也可以给自己1分钟时间考虑下。 先来说说人类和火星的一些事吧。太阳系9大行星(2006年后去掉冥王星后是8大行星）火星是距离地球最近的行星了，人类一直对这位邻居很感兴趣，早在60年代就开始用望远镜观测火星，1971年苏联火星3号登陆器成功在火星软着陆成为第一个抵达火星的探测器，随后美国的登陆器也登陆了火星，2021年5月15日，中国的祝融号也成功登陆了火星。 当然对火星的研究也是明明白白的，火星的体积大小是地球的1/6，重量为地球的1/10，表面环境是9大行星中最接近地球的，和地球一样有四季之分，温度也非常接近地球，而且还观察到火星表面常常会有大规模的沙尘暴发生，说明有流向空气存在，以二氧化碳为主。这些探测结果对人类的意义太重大了，包括人类迁移火星计划、火星开采等都有了无限可能，与所投入的金钱人力相比，回报价值真的是无穷的。看吧，我举了这个例子能回答之前我提的那个问题吧。当然这只是火星，往深点想，放眼整个银河系整个宇宙呢，万一还有其他的外星文明呢，其他的文明进化程度远高于我们呢，这些作为后话，再下一个章节慢慢说。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:3","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"4 《三体》之外的故事 – 寻找地外文明 看了《三体》的小伙伴应该有印象吧，叶文洁在红岸基地通过太阳天线往浩渺宇宙发出了第一声呼喊，几年后收到了三体文明的回复：不要回答！不要回答！不要回答！ 当时我读到这里真的是被震撼到了，一直以来我只是在关注自己的一亩三分地，工作生活朋友，再往大点，国家、地球环境啥的，但从来没有想过，除了地球文明外，在浩渺宇宙是否还有其他的文明呢，有另外一个文明类似于人类，进化程度或低或高于人类文明，他们也在一直寻找着其他文明。哇，想想就太刺激了。其实现实生活中，对外星文明的探索和寻找就一直在进行中。 SETI：Search For Extra Terrestrial Intelligence. 这个项目最早是1960 年美国天文学家弗兰克.德雷克发起的实验项目，通过射电望远镜去探测整个外天空。解释下射电望远镜，不是常规的光学望远镜通过观察的方式去探测，而是通过接收信号的方式。《三体》里的红岸基地，有一个监听基站接收外太空的信号，类似于那个，正常情况下是噪声，如果有接收到外太空规律信号，就能够捕捉下来进行解译分析，射电望远镜就是类似于这个。这个项目持续了很多年后很可惜没有什么收获，之后光听不行啊，得直接出门去找啊，所以后续又有了一些新的行动。 1972年美国就发射了无人行星探测器先驱者10号，这个探测器就往外太空自由飞行，当然还携带了一些人类的信息的金箔，现在貌似是飞出了冥王星，要等到回复也要等几百年了。 分割线，回到《三体》这本书，来谈谈书中印象比较深的一些情节。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:4","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"5 黑暗森林法则 黑暗森林法则应该是贯穿整个《三体》的主线，第二部的书名就叫“黑暗森林”，也正是因为罗辑掌握了黑暗森林法则，所以成为三体人最忌惮的威胁，同时罗辑也通过黑暗森林法则延缓了地球的毁灭，可以说黑暗森林法则是宇宙间的生存法则。我来说说这个吧。 宇宙文明有两条公理：1） 生存是文明的第一需要。 2）文明不断增长和扩张，但宇宙中的物质总量保持不变。 基于这两条定理可以推测演绎出整个宇宙社会的全貌。第一条很好理解，但第二条可能有人会说宇宙这么浩瀚广阔，物质都不缺啊。是的，宇宙很大，但生命更大，宇宙物质总量基本恒定，但生命是以指数增长的啊，把眼光放得更加长远，一百万年、一千万年后呢，按照现在的发展速度地球文明就可以挤满整个银河系。 再来列几个概念： 文明中的善意和恶意，在宇宙文明中对善意和恶意加下限制，善意是指不主动攻击和消灭其他文明，恶意则相反。 猜疑链。是指两个文明在形成交流后基于宇宙文明公理所建立的无穷无尽的猜疑。 不好理解是吧，可以这么理解，比如地球探测到了另一个外太空文明，地球是善意文明，但地球文明不知道对方是怎么想我的，即使知道了对方把我当成善意的，但不知道对方怎么想我怎么想你的，这种猜疑链会一直延伸,这种延伸是和所处的生态圈有关，在地球上，大家都属于同一个物种，所处的环境一样，这种猜疑链可能在三至三层就结束了，但在宇宙中，各自的文明完全是独立的，这种情况下，猜疑链会被无限放大。 技术爆炸。这个应该也好理解，人类文明有五千年历史，地球生命史长达几十亿年，而现代技术也就三百年时间就发展起来了，你想想，三百年的技术变化就有这么大，地球是300年，你没有理由认为宇宙文明没有比地球快的，所以假如有一个文明知道了地球文明存在，即使比你弱下，但也不排除技术爆炸的可能，一下子就走到你的前头了。技术爆炸是无规律，在宇宙时间轴上瞬时的。 说了前面这些，再来理解黑暗森林法则就非常容易了： 宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都小心翼翼…… 他必须小心，因为林中到处都有与他一样潜行的猎人。如果他发现了别的生命，不管是不是猎人，不管是天使还是魔鬼，不管是娇嫩的婴儿还是步履蹒跚的老人，也不管是天仙般的少女还是天神般的男孩，能做的只有一件事：开枪消灭之。在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的生命都将很快被消灭。这个也是对费米悖论的解释。 这个就是著名的黑暗森林法则，因为罗辑研究过宇宙社会学，深谙此法则，而更高文明的三体文明当然也深谙此法则。所以罗辑一直是三体人最忌惮的敌人，同时也通过暴露三体星位置坐标使整个三体文明在宇宙中消失。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:5","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"6 不要回答！不要回答！不要回答！ 整个故事就是从地球人叶文洁和三体星1379号展开，而这两个星体上最普通的普通人竟然决定了两个文明的发展和灭亡。看到这一段我就从前面昏昏欲睡的剧情中突然一下子就觉醒了，第一部前面剧情看起来确实有点不知所云，但这里故事就推向高潮了，叶文洁向寂静宇宙的第一声问候被三体星上1379号监测员监听到，而这一生有可能改变三体星摇摇欲坠的文明环境。三体星由于是有三颗恒星，所以他们的纪元是没有规律的，恒纪元和乱纪元交替出现，而且没有时间规律，在三体星上的文明一直都生活在水深火热中，随时要做好脱水的准备。由于特殊的生存环境，三体星是高度集权且没有感情，交流方式是直接思想的交流，没有语言的包装，所以三体星一直在监听探索宇宙中的其他文明，是否有更好的适合居住的环境。按照常理来说，地球的这一声问候是三体星的救命稻草，等候了几万年的一次机会，但1379号这么一位和平使者，这么一个善良的三体人尽然出自善意提醒，让地球文明不要回答，不要暴露自己的位置，这是何等的无私，何等的思想高度。 当叶文洁收到1379号介绍的三体星的糟糕生存状况后，叶文洁终于还是发了回复：到这里来吧，我将帮助你们获得这个世界，我的文明已无力解决自己的问题，需要你们的力量来介入。 多年后叶文洁成为了地球三体叛军的精神领袖，她是一个理想主义者，是一个极端的理想主义者，自己的悲惨社会时代遭遇让她坚信只有更高文明才能拯救地球文明，但就是这么一个灾难的缔造者却让人恨不起来，我也感觉奇怪，在她生命的最后阶段，也是她把黑暗森林法则教给了罗辑。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:6","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"7 你们是虫子！ 哈哈哈，看到智子发给地球的只有这5个字的信息时太震撼了，虫子，多么的藐视。地球一直是偏于一偶，各种飞船探测器去探测外空文明，认为自己就是宇宙的主，但当知道了另一个外星文明的存在，并小有进展的截获了他们的动态和情报后，我想地球人内心还在想着他们的文明肯定是低于地球文明，等待地球文明去解救。收到这么一个来自于另一个生存状况如此恶劣的三体文明发来的嘲讽：你们是虫子！这是何等的藐视，那一瞬间，地球人的尊严和自信都被击碎了吧。 还是大史的一番话重拾了被浇灭的信心：人类一直在和蝗虫斗争，用了各种方法，用尽各种毒剂，用飞机喷洒，引进和培养它们的天敌，搜寻并毁灭它们的卵，用基因改造使它们绝育等，但在这场漫长的斗争伴随着整个人类文明，现在仍然胜负未定，虫子并没有被灭绝。虫子从来就没有被真正战胜过。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:7","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"8 面壁计划 真的是佩服大刘的想象力，竟然想出了面壁计划这么个情节。针对智子对地球的监视以及三体人特殊的交流方式，面壁计划也就应运而生，面壁计划的四位面壁人针对三体星的策略也让我脑洞大开。第一位泰勒想的是用太空敢死队，用球星闪电把地球军打造成幽灵部队，这样这一只不死的幽灵部队就可以去对抗三体军了。哈哈哈，感觉这一段很美国，用强去碰强。第二位是雷迪亚滋，是计划在水星背后部上数量惊人的核武器，用此来作为要挟和三体军谈判，如果执意攻击地球就同归于尽。第三位是希恩斯，思想钢印，这东西真的是强，利用思想钢印来加固地球军必胜的信心，能有效的抵制逃生派和悲观主义者，这个脑洞太大了。第四位是罗辑了，罗辑前期并没有采取任何手段，也不知道自己为什么能被选中当面壁者，不过最终就是他的面壁计划是最有效的，也就是黑暗森林法则。 当然随着而来的，就有一句口头禅：我是你的破壁者。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:8","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"9 没关系，都一样的 章北海是全剧中除罗辑之外我最喜欢的角色，当然章北海和维德是一类人，有着超前的预判及坚定的信念，而且为了信念能不择手段，坚信自己的判断。 ​ 在看书的时候，我也经常把自己代入到三体的世界里，我在想如果我在那种地球大灾难的时候我会怎么想，整个地球有多少人能保持理性及坚定的信念，并能准确的预测到未来。我的脑海中时常浮现章北海孤傲、冷峻的背影，虽然他只是一名军人，并没有手握实权去改变什么，但他坚定自己的信念，并为自己的信念去奋斗乃至牺牲自己。在初期，他伪装成坚定的地球军必胜的乐观主义者，和逃亡主义者形成鲜明的对比，让所有人都认为他是坚定的胜利主义者。后期他被冬眠运往参加最后的末日之战，当在化学火箭和核动力火箭间取舍时，毅然干掉了化学火箭的专家，使对后续生产核动力火箭成为可能，最后在被选为舰长带领自然选择号逃离地球，就像一头狼带领一群羊。终于，黑暗战役中，自然选择号被击毁，章北海终于解脱了，他终于可以做自己了，他是逃亡主义者，但没关系，都一样的。 章北海完成了他自己的使命，他就是孤单英雄！ ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:9","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"10 我对三体世界说话 当罗辑站在地球命运的十字路口时，要正面硬刚三体文明说出：我对三体世界说话。我的情绪达到了顶点，此刻只想说，罗辑是地球上唯一的男人，也是全剧中我最崇拜最喜欢的角色。 罗辑并不是一个完美的主角人设，他从来没有把自己标榜为超级英雄，也没有那种正义凛然富有号召力的形象，恰恰正是因为这样他才受到很多人的追捧。成为面壁者前，他放荡不羁，他恃才傲物，不仅精通物理学，还熟知社会学、文学，研究宇宙社会学也是因为冷门对以后找工作有利，在肩负地球使命前，他就是一个小人物，及时行乐不拘小节的小人物。当小人物被历史选中肩负拯救地球的使命时，有多少人能保持初心或承受压力？罗辑被选中为面壁者时，第一反应是坚决的放弃这个使命和特权，当知道无法放弃这个身份后他非常的鸡贼，利用特权过自己理想中的生活，地球的未来与我何干？还有四个世纪时间，享受当前不好吗？哈哈哈，真的是太真实了，生活有很多中活法，而把握当前显然是最好的活法。后面他真正发力去找解决方法也是为了自己的爱人和孩子，哇，这就是真实，多么的贴近我们，说实话作为一个老百姓最大事不就是老婆孩子热炕头吗？国家、地球的命运与我何干？这不就是人生的大智慧吗？看到这里真的很感动，我们很多人每天努力工作，努力加班，每天被工作压的喘不过气来，还得要和别人比较，拼命买房换房，晒朋友圈博取那一点虚荣心，透支着自己的家庭时间去拼一些镜花水月，最后其实是和自己的初心背道而驰了。 罗辑活的太真实了，有点像大刘的真实写照。之前看大刘的采访，谈论他对名声、人气以及文学的看法，他也非常实诚的表达就是多卖点书、多挣点钱，太真实了。不过罗辑的强大还远远不止这些，当他从拯救人类的英雄变成受所有人排挤时，他还是用自己的最后力量去拯救人类，我要和三体世界对话。 到后面他成为执剑者，一个人默默的面壁50年守卫着地球文明，再到后来的地球守墓者，啊，只想说：纵观人类历史，他的胜利无人能及。 诚然，罗辑和程心相比，他更加的真实，他能为自己而活，在需要他肩负责任时也能倾其所有，他就是一位充满智慧的智者，不卑不亢，坦然面对所有！ 我何时能像罗辑一样，掌握人生的真谛，智慧的过完自己的一生。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:10","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"11 前进！前进！不择手段的前进！ 维德和章北海是一类人，有坚定的目标，坚定的信念。有的时候是需要有这种精神，特别是在迷茫没有方向的时候，在为未来无病呻吟的时候就需要这种精神，前进、前进、不择手段的前进。没有什么好怕的，勇敢的往前冲就行了，人的很多恐惧是自己强加的，战胜恐惧的唯一方法就是去面对它，当面对它了，你就不怕了。所以像维德和章北海，在我以后的人生道路上，我会拿来激励自己，没有什么好怕的，干就完了。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:11","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"12 弱小和无知不是生存的障碍，傲慢才是！ 有两个故事： 有一个神枪手在练习打靶，每隔10cm 就打了一个洞，设想下这个靶子上生活着一种二维智能生物，他们中的科学家在对自己的宇宙观察后发现了一个伟大的定律：每隔10cm 就必然有一个洞，他们把这个神枪手的随意行为当作自己文明的铁律。 一个农场里有一群火鸡，农场主每天早上10点钟会准时给他们喂食，火鸡中的一名科学家观察这个现象一年都没有变过，于是它也发现了自己宇宙中的铁律：每天早上10点就有食物降临。它在感恩节向大家宣布了这个定律，但这天早上10点食物没有降临，农场主进来把它们都捉去杀了。 这两个有趣的故事也可以类比到地球文明身上，我们以为自己是整个宇宙的中心，我们是最高等的文明，但有没想过可能地球文明也是偶然的一个洞，在更高等文明面前我们就是任人宰割的一只火鸡。 《三体》中有很多情节描写了人类的傲慢，印象最深刻的就是经历大低谷后人类工业进入了新的高度，太空技术蓬勃发展，太空舰队严正以待等待三体舰队的到来，而且坚信能不费吹灰之力歼灭三体舰队。看到这一段时我以为所有的地球人类都打了思想钢印，就是那种坚信人类必胜的钢印，实际上是没有。这种傲慢也是人类的劣根性，是好了伤疤忘了痛，毕竟地球文明自人类以来还是比较太平，没有非常恶劣的自然生存环境，在这种温床中难免会忘乎所以。当三体的水滴以不费吹灰之力消灭了人类的太空战舰时，所有人都崩溃了，那种绝望的崩溃。还有三体水滴威胁地球，罗辑用黑暗森林威慑三体军，是地球获得了短暂的和平，人类又沉浸在傲慢之中，觉得依靠这个可以永远和三体文明和平共处，这又是典型的好了伤疤忘了痛，三体星没有放弃任何的机会去侵占在他们眼中的地球天堂，努力的学习地球的文明，地球的文化，补充自己文明的劣势等等，最后果然还是找到了机会，一击即溃了地球军。 弱小和无知不是生存障碍，傲慢才是！弱小我可以慢慢强大，无知我可以学习知识，但如果仗着觉得自己是宇宙的王，去主动暴露自己，这是对宇宙文明的傲慢，这种傲慢也是会付出沉重的代价！ ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:12","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"13 请求一块二向箔，清理用 震撼！ 我们苦心经营引以为傲的地球文明在更高文明面前就是一只蚂蚁，一块二向箔就能把整个太阳系清理干净！ 就像炎热的夏天，你在你家的后院发现了一群蚂蚁，然后为了驱赶这群蚂蚁，你回到家里拿出一盆热水泼向这群蚂蚁，对于这群蚂蚁来说，在它们的文明里就是遇到了灭顶之灾，它们苦心经营的家园被外来神秘力量摧毁，而它们耗费一生也找不到对抗这神秘力量的方法。但对于你来说，蚂蚁太渺小了，你能轻而易举左右它们的命运，这就是降维打击吧。 让我佩服的是刘慈欣老师强大的想象力，最后击败人类的并不是黑暗森林法则，而是高维度的打击。黑暗森林法则是适用于相同维度间，在更高维度是不适用的，因为低纬度根本是无法威胁到高维度，所以高维度打击低维度就直接降维了。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:13","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"14 极权只需五分钟 太空是一面放大镜，可以瞬间把人类的阴暗面放到最大，当人类真正流落太空时，极权只需五分钟。 社会给予人的身份太重要了，我们在社会上生存，有自己的国家、身份等，但如果哪一天你不属于任何一个国家，你也没有人身份，而像你这样的人还有一大群，你会怎么想？比如在外太空呢，你永远也回不到地球了，你会怎么想？其实这个时候你就是外太空文明了，你就不属于地球人了，你可以在你的文明里做任何事，包括创建自己的法律、制度、文化，而这个时候人类的本性也就最大程度的暴露，极权也就在5分钟内形成了。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:14","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"15 我的一生，就是在攀登一道责任的阶梯 一直以来不知道怎么评价程心，很复杂，她的形象是如此的正面，如此的有责任感，很符合现在人类的道德规范，但就是这么一个如此道德感、责任感的人，一次次的把地球文明推向了万丈深渊。我其实不太理解刘慈欣老师设计程心这个角色的用意，可能是暗讽人类的这种道德包装并不有利于文明的进步？但如果现实中每个人都像三体人那样，不带任何感情的去交流，生存利益至上，那整个社会会更加黑暗吧。可能这种文明能促进文明的发展，但在这样的文明中生活，也是水深火热了。 在云天明的眼里，程心是他永远也无法接近的女神，他只是默默的去保护这位心中的女神，直到地球的毁灭。作为执剑者，仅仅1秒中，就被三体人攻破，知道她无法承担这份重任，结果也确实是无法承受。我看到这段时，也类比自己如果是执剑人，我是否有勇气去按下那颗按钮，我不知道，但是我知道的是这份压力很大，是关系到整个地球的生死存亡，人是有理性和感性的，如果光靠理性去做决定那就是机器了，这种理性、信念、决心也只有罗辑、维德、章北海能胜任了。 再到后来的光速飞船计划的终止，掐灭了人类的最后生存机会。但凡是冒险威胁到地球的存亡，程心就像一位母亲一样靠着这份责任去呵护自己的孩子，所以，永远她都是在完成她的责任。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:15","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"16 把字刻在石头上 科技发展的越来越快，我们的存储介质能存储的信息也越来越大，但如何能永远的保留下来呢？光盘、硬盘所有的存储介质都有存储周期，在人类历史，这个存储周期足够了，但如果放眼整个宇宙呢？人类的这段历史就太短了，终极之法还是回归到本质，用石头去保留，回到最原始的方法，去雕刻，去记录。 科技的发展给我们的生活带来了很大便利性和多样性，我们的通信速度越来越快，一条微信一个电话就能把信息传给地球的另一端，每天刷着手机看着视频就能掌握到世界发生的所有事情，出门开车地图导航带我们去任何地方，智能手环记录呵护着我们的身体健康……. 这些科技发展给我们带来便利和快乐的同时，也在消磨着我们的意志。人与人之间的距离真的因为信息传递加快而缩短了吗？每天刷着视频看着新闻真的让我们感到快乐了吗？世界因为科技的发展而没有战火了吗？我们的身体也更加健康了吗？并没有，我时常回想起小时候，那时候科技发展的不快但我是真的快乐，能在清澈的小河里洗澡摸鱼，能和小伙伴在乡间的飞奔嬉戏，能时刻陪伴在父母身边。科技的发展给我们带来的我们的精神压力也大了，回归到本源或许能带给我们最质朴的快乐。 ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:16","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"17 尾记 这几天一直都沉浸在三体中，搜相关的视频、知乎的问答关于三体的，感觉这就是一本好书的魅力吧。看完这本书后思想也变得更加深邃和广阔了，人类从发现人类化石推算也就500万年，而文明史也就8千年，但相对于这个宇宙时间长河就太渺小了，当前的这些喜怒哀乐算得了什么呢，人类的出现本来就是偶然，而你的出现也更加是偶然，你的生命也就最多100年，有什么好可怕的呢？ 对待生活不妨大胆一点，对待每一天也不妨更加的热情一点，因为你也不知道是否一个二向箔我们就都在“画”里了。 附三体的经典语录： https://www.bilibili.com/read/cv1248329/ ","date":"2022-11-13 19:14:00","objectID":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:17","tags":["读书整理","生活感悟"],"title":"《三体》读书笔记","uri":"https://yeliansong.github.io/2022-07-17-%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["生活感悟"],"content":"读书感悟","date":"2022-09-27 19:14:00","objectID":"https://yeliansong.github.io/2022-2-14-%E7%A8%8B%E5%BA%8F%E5%91%98%E8%A6%81%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81%E5%81%A5%E5%BA%B7%E8%AF%BB%E5%AE%8C%E6%A8%8A%E7%99%BB%E6%8E%A8%E8%8D%90%E7%9A%84%E9%A5%AE%E9%A3%9F%E6%9C%AF/","tags":["读书整理","生活感悟"],"title":"程序员要怎么保持健康？读完樊登推荐的《饮食术》我懂了","uri":"https://yeliansong.github.io/2022-2-14-%E7%A8%8B%E5%BA%8F%E5%91%98%E8%A6%81%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81%E5%81%A5%E5%BA%B7%E8%AF%BB%E5%AE%8C%E6%A8%8A%E7%99%BB%E6%8E%A8%E8%8D%90%E7%9A%84%E9%A5%AE%E9%A3%9F%E6%9C%AF/"},{"categories":["生活感悟"],"content":"前沿 关于吃的问题我一直都挺感兴趣，但是现在网上各种fake 科普太多了，一时说要每天控制碳水、脂质摄入，又有说是正常吃就可以，一度让我很难选择。无意中听了樊登读书讲解《饮食术》这本书，也是比较信任樊登老师，相信应该是良心权威科普，所以也就认真去看了这本书。真的是不看不知道，看了吓一跳，太颠覆我之前饮食的认知了，里面的很多观点异常的大胆，初看我也是半信半疑，然后各种查资料、咨询朋友，书中的观点都是正确的。 作为一个每天缺乏运动的程序员，身体健康真的是太重要了，随着年龄增长，身体上各种各样的问题都或多或少的在暴露，比如脂肪肝、肚子慢慢凸起、肥胖等等。而很多时候我们又不太注重饮食，也不是不注重，主要还是对科学饮食习惯一无所知，所以平时也就逮着啥就吃啥，吃的时候是一时爽，吃完就后悔。这篇文章也是我看完这本书后，对里面一些知识点做一些提炼，方便没时间看全书的朋友快速掌握书中的知识点。 作者简介 牧田善二(Makita Zenji),日本人，AGE牧田专科医院院长，糖尿病专科医生，医学博士。 饮食的16谎言 没有列举完所有的16个谎言，有一些是关乎日本的饮食习惯，我们这边没有参考价值，所以忽略。 像大部分人可能会认为低脂肪就是好的，我们身体变胖是因为吃了太多脂肪；还有均衡饮食就觉得能控制身材；减肥会使肌肉变少等。这些都可以说是fake 新闻，后面你会了解到什么使我们变胖，减肥并不会使肌肉变少等。 三大营养素的最佳摄取 三大营养素是：糖类、脂质和蛋白质。 糖类是能量源 脂质是构成细胞膜的成分 蛋白质是肌肉和骨骼不可或缺的重要成分 关于这三者的摄取，以及每一种摄取可能导致的后果，可以看下图。 看这个图可以提炼出： 一定要减少碳水化合物摄入，设置可以用脂质和蛋白质替代。而脂质要食用好的脂质，多食用不饱和脂肪酸食物，尽量少使用饱和脂肪酸食物。 各种食材的食用 全方位饮食，吃肉，无论是脂肪还是骨髓，甚至连生殖器也无一剩下，全部吃掉。 越天然的越好，超加工食品会诱发癌症 这个图是列出了部分要经常使用的食物，可以替代碳水化合物的。 鱼肉和其他肉应交替摄取，而且鸡肉摄取量要偏多，猪肉适量，牛肉偶尔使用。 终极身体调养法 白米饭吃多会减少寿命，只要减少碳水化合物摄取，血糖就会自然正常 多摄取优质蛋白，选择豆腐、纳豆、鸡蛋等，尽最大努力多吃蔬菜 减少盐分的摄取 有意识积极吃无农药的蔬菜、特级初榨橄榄油、大豆制品、青背鱼、鸡肉等，绝对不要吃快餐食品、便利店小食品 炸薯条是绝对要避免的魔鬼食品 细嚼慢咽稳血糖 高温加热要避免，高温加热食品会使其快速老化 贝类、海藻中富含镁，另外颜色较深的蔬菜、豆类、鸡蛋、菌类也富含镁 少食多餐有益健康，不吃早饭会加速衰来和糖尿病 鱼肝油是从鳕鱼、鲨鱼等鱼的肝脏中提取的液体脂肪，富含维生素A、维生素D、矿物质等优质成分 铁锅烹任改善贫血 面部按摩仪增皱纹 结语 我只是把书中的一些要点进行了概括，书中还有很多的一些理论知识，感兴趣的同学可以慢慢研读，相信肯定能给你带来帮助。 最后送上一句话：要想能够过上健康的生活，你首先要从承认自己一无所知开始。承认自己之前的东西有可能是错的，这时候你才有可能接受新的知识、新的概念。 ","date":"2022-09-27 19:14:00","objectID":"https://yeliansong.github.io/2022-2-14-%E7%A8%8B%E5%BA%8F%E5%91%98%E8%A6%81%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81%E5%81%A5%E5%BA%B7%E8%AF%BB%E5%AE%8C%E6%A8%8A%E7%99%BB%E6%8E%A8%E8%8D%90%E7%9A%84%E9%A5%AE%E9%A3%9F%E6%9C%AF/:0:0","tags":["读书整理","生活感悟"],"title":"程序员要怎么保持健康？读完樊登推荐的《饮食术》我懂了","uri":"https://yeliansong.github.io/2022-2-14-%E7%A8%8B%E5%BA%8F%E5%91%98%E8%A6%81%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81%E5%81%A5%E5%BA%B7%E8%AF%BB%E5%AE%8C%E6%A8%8A%E7%99%BB%E6%8E%A8%E8%8D%90%E7%9A%84%E9%A5%AE%E9%A3%9F%E6%9C%AF/"},{"categories":["运维相关知识"],"content":"日常运维经验","date":"2022-05-23 19:14:00","objectID":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/","tags":["运维","经验梳理"],"title":"一次由iNode 引发的惨案，爆肝四小时终于理解了iNode","uri":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/"},{"categories":["运维相关知识"],"content":"1 背景 一次在做程序包变更时，程序包已经更新到最新版本，需要重启进程，就一直重启不成功。查看启动的错误日志，发现是一直在创建文件时不成功，当时想法是机器磁盘可能满了，查看磁盘使用，发现正常，瞬时就懵逼了，一直想不到是啥问题。突然想到之前有了解过Linux 系统有inode 一说，中文译名是：索引节点。创建的每一个文件都有一个inode，这个inode是用来记录文件的基础信息，这个节点资源也是有限的，马上去查了下，发现inode占用已经100% 了，这完犊子了，马上清理，问题解决。这篇就来说说这个吧。 2 iNode 的理解 ","date":"2022-05-23 19:14:00","objectID":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/:0:0","tags":["运维","经验梳理"],"title":"一次由iNode 引发的惨案，爆肝四小时终于理解了iNode","uri":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/"},{"categories":["运维相关知识"],"content":"2.1 磁盘存储 要想理解iNode，首先得需要知道Linux 的磁盘存储的一些知识。Linux 磁盘的最小的存储单位是片区，就是sector,一般一个扇区的大小是512 bytes，操作系统读取数据时候不是以扇区为单位来读，这样就太慢了，而是以块来读取，也就是block，一个block 会有多个sector，一般一个block 是4KB，8个sector。这8个sector 是连续的。操作磁盘命令是 fdisk。 可以看到磁盘的分区、分区大小、sector、block 等相关的信息。okay，说了这么多，其实需要知道的一个信息是文件存储的最小单位是 block，那这个和iNode 有什么关系呢？ ","date":"2022-05-23 19:14:00","objectID":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/:1:0","tags":["运维","经验梳理"],"title":"一次由iNode 引发的惨案，爆肝四小时终于理解了iNode","uri":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/"},{"categories":["运维相关知识"],"content":"2.2 iNode 的内容 先来看看iNode 中存的信息有哪些？ 我随便开一个文件，看看这个文件的iNode 信息： - File: 文件 - Size: 文件的大小 - Block: 所属的块 编号 - Gid: 文件的Group ID - A M C: 文件的时间戳，分别上次访问、文件修改、iNode 修改的时间戳 - Inode: 文件的Inode 值 - Links: 文件的链接数 看这个iNode 内容，就不难理解iNode 的作用了。可以理解为操作系统给创建的每一个文件一个iNode 节点，也就每个文件和iNode 号是一个map关系，存储时候这个iNode 号才是关键。当需要对该文件操作时，分为三步：1）通过文件名找到iNode 节点号。 2） 通过iNode 节点号获取整个iNode 信息。3）根据iNode 信息找到文件所属的Block，读出数据。 可以通过ls -i 来看文件的iNode 号。 ","date":"2022-05-23 19:14:00","objectID":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/:2:0","tags":["运维","经验梳理"],"title":"一次由iNode 引发的惨案，爆肝四小时终于理解了iNode","uri":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/"},{"categories":["运维相关知识"],"content":"2.2 iNode 大小 iNode 也是会消耗硬盘空间的，硬盘格式化后会分为两个区，一个是数据区，存放文件数据；另一个是iNode 区，用来存放iNode 所包含的信息。每个iNode 大小一般是128字节或256字节，可以用dumpe2fs 命令来查看iNode 大小。 同时系统分配的iNode 节点个数是有限的，所以很有可能发生iNode 节点用完的情况，用完后，就无法在硬盘上创建新的文件了。所以就发生了文章开头的事情。关于iNode 写完后怎么清理，看下面文章描述。 ","date":"2022-05-23 19:14:00","objectID":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/:3:0","tags":["运维","经验梳理"],"title":"一次由iNode 引发的惨案，爆肝四小时终于理解了iNode","uri":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/"},{"categories":["运维相关知识"],"content":"2.4 iNode 含义小结 通过介绍，可以看出iNode 的Linux 设计哲学，Linux 是一切皆文件，而文件的标识就是iNode，所以文件名对于Linux 系统来说就不重要了，重要的是独一无二的iNode，有了iNode 节点号，就能准确的找到Linux 里的所有文件。 3 iNode 的延伸 ","date":"2022-05-23 19:14:00","objectID":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/:4:0","tags":["运维","经验梳理"],"title":"一次由iNode 引发的惨案，爆肝四小时终于理解了iNode","uri":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/"},{"categories":["运维相关知识"],"content":"3.1 目录文件权限 文件都是在目录中，在Linux系统中，目录也是一种文件，打开目录实际上就是打开目录下的文件。目录文件就是目录下文件名和iNode 节点信息的集合。 读取文件的iNode 节点是需要执行权限，通过这个就很容易理解目录权限和文件权限的关系了。 如果目录没有执行权限，基本啥都干不了，不能读取目录下文件的一些信息，执行权限对于目录权限来说是至关重要的。 root 权限除外哈，root 权限基本就是超人，内裤外穿，不受任何影响。 3.2 硬链接 有了iNode 的理解，对Linux 里的一些链接的理解和使用也就比较容易了。 上面说过，一般情况下一个文件名和一个iNode 号是一一对应关系，但是也可以多个相同的文件名对应一个iNode 号。这样就可以用不同的文件名来访问同样的内容，对文件内容修改会影响到所有指向这个iNode 的文件；但是删除一个文件吗文件，不会影响另一个文件对这个iNode 的访问。这就是用的很多的硬链接。 掌握了iNode，对硬链接也比较容易理解，文件的实际内容只和iNode 节点有关，和文件名没关系。 我创建了一个test.txt 的一个硬链接，可以看到这两个文件的iNode 值是一样的。也可以看到链接数是2，如果删除其中一个文件，链接数会减1，只到为0 后就会回收这个iNode 号码。 这里说明下目录的iNode，创建目录后，默认会生成两个目录：‘.’ 和 ‘..’。前者的iNode 号码就是当前目录的iNode 号码，后者的iNode 号码是当前目录的父目录的iNode 号码。 3.3 软链接 还有一种是软链接，也叫符号链接，它是两个文件A 和 B的iNode 不一样，但是文件A 的内容是文件B 的路径，系统会自动将访问指向B，所以无论打开哪个文件，都是操作的的文件B。 所以文件A 是依赖于文件B，如果删除了文件B，文件A 也就打不开了。这个和硬连接的区别是，文件A 指向的是文件B 的文件名，而不是文件B 的iNode 号码。 4 iNode 资源耗尽的解决 回到文章开头的问题，通过df -i 看，我的iNode 使用已经是100% 了，怎么解决呢？ 基本思路就是找文件句柄在哪个路径下，一般iNode 耗尽肯定是有进程或任务一直在创建文件，导致耗尽。 1） 查看文件最多的目录 for i in /*; do echo $i; find $i | wc -l; done 如果确定哪个目录，可以吧/* 写的具体点。 2） 删除大量文件 ls | xargs -n 1000 rm -rf 删除就可以了，用xargs 命令。 找到问题后要避免这种大量创建文件的问题。 ","date":"2022-05-23 19:14:00","objectID":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/:5:0","tags":["运维","经验梳理"],"title":"一次由iNode 引发的惨案，爆肝四小时终于理解了iNode","uri":"https://yeliansong.github.io/2022-1-28-%E4%B8%80%E6%AC%A1%E7%94%B1inode-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88%E7%88%86%E8%82%9D%E5%9B%9B%E5%B0%8F%E6%97%B6%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86inode/"},{"categories":["技术归类"],"content":"python小工具","date":"2022-03-28 19:14:00","objectID":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/","tags":["技术","小工具"],"title":"wxpy+图灵机器人微信聊天机器人--附源代码","uri":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"categories":["技术归类"],"content":"1 背景 看到很多小伙伴用微信玩聊天机器人，能自动回复，看着还挺像模像样的，心里痒痒，也想着自己做个聊天机器人玩玩，初步想法是能每天定时给女朋友“早安”消息，推送当天的天气，引入图灵机器人能自动回复女朋友的消息，尽量回答的有水平点。 2 方案实现 ","date":"2022-03-28 19:14:00","objectID":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/:0:0","tags":["技术","小工具"],"title":"wxpy+图灵机器人微信聊天机器人--附源代码","uri":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"categories":["技术归类"],"content":"2.1 工具 微信号两个，用来做测试 调用wxpy pthon库 python3.5 及以上版本 注册图灵机器人 ","date":"2022-03-28 19:14:00","objectID":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/:1:0","tags":["技术","小工具"],"title":"wxpy+图灵机器人微信聊天机器人--附源代码","uri":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"categories":["技术归类"],"content":"2.2 整个原理 原理是非常简单的，wxpy 是在itchat 基础上，对一些接口进行了优化，并提升了模块调用的易用性，同时对部分功能也进行了扩充。itchat 大家都知道是一个开源的微信个人号接口，这里列下wxpy 可以做的一些事： 控制路由器、智能家居等具有开放接口的玩意儿 运行脚本时自动把日志发送到你的微信 加群主为好友，自动拉进群中 跨号或跨群转发消息 自动陪人聊天 逗人玩 … 附上wxpy 的github： https://github.com/youfou/wxpy 原理也是非常简单，wxpy 是利用网页版微信API来实现微信里的联系人搜索和消息发送，同时wxpy 是支持图灵机器人接口，所以可以将机器人的自动回复发送。这里要注意，如果你的微信不支持网页版登陆，整个也是跑不通的。 ","date":"2022-03-28 19:14:00","objectID":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/:2:0","tags":["技术","小工具"],"title":"wxpy+图灵机器人微信聊天机器人--附源代码","uri":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"categories":["技术归类"],"content":"2.3 实现步骤 安装wxpy sudo pip3 install -U wxpy 图灵机器人注册 可参照这个链接，购买一个月体验版玩玩：https://www.turingapi.com/ 代码 # -*- coding: UTF-8 -*- # 防止搜的用户名是中文 from wxpy import * # 调用wxpy 包 bot = Bot() # 初始化机器人，网页扫码登陆 friend = bot.friends().search('we_test')[0] #搜索昵称为 test 的好友 friend1 = bot.friends().search('大聪明')[0] #搜索昵称为 大聪明 的好友 group = bot.groups().search('test')[0] #搜索为 test 的群组 tuling = Tuling(api_key='58e4c4c..........') #调用图灵机器人API #主动发送消息 friend.send('hello world') #向 test 好友主动发送 ‘hello world’ group.send('for test') #向test群组发送消息 #自动回复 @bot.register(friend) def reply_my_friend(msg): tuling.do_reply(msg) #图灵机器人自动回复 @bot.register(friend1) def reply_my_friend1(msg): tuling.do_reply(msg) #图灵机器人自动回复 @bot.register(group) def reply_my_group(msg): if isinstance(msg.chat, Group) and not msg.is_at: #msg.chat 和 msg.is_at 可参考文档类型说明。@ 我才回复 return else: tuling.do_reply(msg) bot.join() #保持登陆状态 ","date":"2022-03-28 19:14:00","objectID":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/:3:0","tags":["技术","小工具"],"title":"wxpy+图灵机器人微信聊天机器人--附源代码","uri":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"categories":["技术归类"],"content":"2.4 改良版本 只是玩一些自动回复还是没啥意思，改良版本加上每天早上和晚上的定点发送“早安”、“晚安”，每隔一小时提醒喝水、走动，同时推送天气信息。 思路就是加一个定时线程，一直跑，然后到固定时间了就调wxpy 的接口去发送通知消息。推送天气信息，我用的是goole 的天气API 接口，也是拉取后解析出需要的信息发送消息。我来贴下代码： #定时推送早安和晚安 def run_thread(): list = [11,12,13,14,15,16,17] #这些时间点发送喝水的通知 while True: now = datetime.now() if now.hour == 6 and now.minute == 00 and now.second == 00: friend.send('早上好呀') # 获取当天的天气 temp,sky = get_weather() #封装了一份函数，调取 friend.send('今天天气:'+ temp + ' ' + sky) elif(now.hour in list) and now.minute == 00 and now.second == 00: friend.send('喝点水，走动下吧') elif now.hour == 18 and now.minute == 30 and now.second == 00: friend.send('工作了一天幸苦了') elif now.hour == 23 and now.minute == 00 and now.second == 00: friend.send('太晚了，早点休息吧') time.sleep(1) 获取天气的接口 #调google 天气API，获取天气信息 def get_weather(): city = \"hubei\" #可修改城市 url = \"https://www.google.com/search?q=\"+\"weather\"+city html = requests.get(url).content soup = BeautifulSoup(html, 'html.parser') # get the temperature temp = soup.find('div', attrs={'class': 'BNeawe iBp4i AP7Wnd'}).text # this contains time and sky description str = soup.find('div', attrs={'class': 'BNeawe tAd8D AP7Wnd'}).text # format the data data = str.split('\\n') time = data[0] sky = data[1] # list having all div tags having particular clas sname listdiv = soup.findAll('div', attrs={'class': 'BNeawe s3v9rd AP7Wnd'}) # particular list with required data strd = listdiv[5].text # formatting the string pos = strd.find('Wind') other_data = strd[pos:] # printing all the data print(\"Temperature is\", temp) #print(\"Time: \", time) #print(\"Sky Description: \", sky) #print(other_data) return temp,sky 简简单单，整个功能就做完了。 ","date":"2022-03-28 19:14:00","objectID":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/:4:0","tags":["技术","小工具"],"title":"wxpy+图灵机器人微信聊天机器人--附源代码","uri":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"categories":["技术归类"],"content":"2.5 项目源代码 运行过程中需要安装的一些库，可以直接pip3 直接安装。 # -*- coding: UTF-8 -*- from wxpy import * from datetime import datetime import threading import time import requests from bs4 import BeautifulSoup def get_weather(): city = \"hubei\" url = \"https://www.google.com/search?q=\"+\"weather\"+city html = requests.get(url).content soup = BeautifulSoup(html, 'html.parser') # get the temperature temp = soup.find('div', attrs={'class': 'BNeawe iBp4i AP7Wnd'}).text # this contains time and sky description str = soup.find('div', attrs={'class': 'BNeawe tAd8D AP7Wnd'}).text # format the data data = str.split('\\n') time = data[0] sky = data[1] # list having all div tags having particular clas sname listdiv = soup.findAll('div', attrs={'class': 'BNeawe s3v9rd AP7Wnd'}) # particular list with required data strd = listdiv[5].text # formatting the string pos = strd.find('Wind') other_data = strd[pos:] # printing all the data print(\"Temperature is\", temp) #print(\"Time: \", time) #print(\"Sky Description: \", sky) #print(other_data) return temp,sky #定时推送早安和晚安 def run_thread(): list = [11,12,13,14,15,16,17] #这些时间点发送喝水的通知 while True: now = datetime.now() if now.hour == 6 and now.minute == 00 and now.second == 00: friend.send('早上好呀') # 获取当天的天气 temp,sky = get_weather() #封装了一份函数，调取 friend.send('今天天气:'+ temp + ' ' + sky) elif(now.hour in list) and now.minute == 00 and now.second == 00: friend.send('喝点水，走动下吧') elif now.hour == 18 and now.minute == 30 and now.second == 00: friend.send('工作了一天幸苦了') elif now.hour == 23 and now.minute == 00 and now.second == 00: friend.send('太晚了，早点休息吧') time.sleep(1) if __name__==\"__main__\": #起一个线程去跑定时任务 bot = Bot() friend = bot.friends().search('we_test')[0] friend1 = bot.friends().search('大聪明')[0] group = bot.groups().search('test')[0] tuling = Tuling(api_key='58e4c4c..................') @bot.register(friend) def reply_my_friend(msg): tuling.do_reply(msg) #图灵机器人自动回复 @bot.register(friend1) def reply_my_friend1(msg): tuling.do_reply(msg) #图灵机器人自动回复 @bot.register(group) def reply_my_group(msg): if isinstance(msg.chat, Group) and not msg.is_at: return else: tuling.do_reply(msg) t = threading.Thread(target=run_thread, name='push_msg') t.start() bot.join() #保持登陆状态 ","date":"2022-03-28 19:14:00","objectID":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/:5:0","tags":["技术","小工具"],"title":"wxpy+图灵机器人微信聊天机器人--附源代码","uri":"https://yeliansong.github.io/2022-01-27-wxpy-%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%99%84%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"categories":["运维相关知识"],"content":"运维相关知识","date":"2021-11-27 15:14:00","objectID":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/","tags":["运维","运维自动化"],"title":"运维自动化 -- Ansible","uri":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/"},{"categories":["运维相关知识"],"content":"1. 运维自动化应用场景 操作系统预备自动化 对主机进行批量操作系统部署。PXE 配置自动化 对主机进行批量配置或对主机的应用程序进行批量配置。 Ansible， saltstack, puppet. Ansible, 用的ssh协议，开箱即用。 saltstack，需要agent端配合，配置部署速度快。 puppet，老牌配置自动化工具，需要agent配合。 提高配置效率，降低人工参与度。 监控自动化 对服务器的应用，性能的监控。 1\u003e 系统与应用监控。 普罗米修斯 2\u003e 日志监控。 ELK 代码持续集成与代码持续发布自动化 ","date":"2021-11-27 15:14:00","objectID":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/:0:1","tags":["运维","运维自动化"],"title":"运维自动化 -- Ansible","uri":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/"},{"categories":["运维相关知识"],"content":"2. Ansible 工作原理 即开即用，没有主从结构。是通过ssh协议来完成对主机的批量管理，Ansible的内部各个功能模块是独立，通过各个功能模块来进行功能的管理。Ansible有一个主机清单，通过在主机清单中设置批量主机的信息，来批量管理。 ","date":"2021-11-27 15:14:00","objectID":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/:0:2","tags":["运维","运维自动化"],"title":"运维自动化 -- Ansible","uri":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/"},{"categories":["运维相关知识"],"content":"3. Ansible 主机清单 Ansible 是通过主机清单来对主机进行操作；同时主机清单也可以对主机进行分组，便于对组进行操作。 主机清单的设置两种方式，一种是直接在清单后添加IP或者主机名。另外一种是添加主机的分组，在分组中添加主机的IP或主机名。 192.168.2.1 monitor 或 [webgroup] monitor ","date":"2021-11-27 15:14:00","objectID":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/:0:3","tags":["运维","运维自动化"],"title":"运维自动化 -- Ansible","uri":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/"},{"categories":["运维相关知识"],"content":"4. Ansible ping 模块使用 场景分析：使用Ansible的ping模块来对其他主机来测试其联通性。 问题分析解决： 首先是将ssh的密钥拷贝到目标主机，使其登陆实现免密登陆。这里来提一嘴ssh登陆其他主机的过程。 ssh密码登陆是用的RSA加密，就是非对称加密。源主机先是生成一对公私钥密钥对，存放在源主机路径下，然后ssh连接时，目标主机会去读取源主机密钥对，用源主机的公钥对密码进行加密，发给源主机，源主机用私钥揭秘，将揭秘后的密码发给目标主机，目标主机判断密码是否正确。 源主机生成密码对 root@agent:/etc# ssh-keygen -t rsa -f /root/.ssh/id_rsa -N '' 密钥对同步 root@agent:/etc# ssh-copy-id vagrant@192.168.2.7 第二步，修改ansible的配置文件，在主机清单中加上要配置的主机IP。 在主机清单中加上要连接的主机IP。 root@agent:/etc# ansible 192.168.2.7 -m ping 192.168.2.7 | SUCCESS =\u003e { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } 证明已经调试通了。 ","date":"2021-11-27 15:14:00","objectID":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/:0:4","tags":["运维","运维自动化"],"title":"运维自动化 -- Ansible","uri":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/"},{"categories":["运维相关知识"],"content":"5. Ansible Cron 实现主机的时钟同步 场景分析：通过cron模块实现远程主机和阿里云服务器的周期性时钟同步。 直接使用cron 命令来实现周期性同步。 root@agent:/etc# ansible 192.168.2.6 -m cron -a 'name=\"test cron1\" \\ \u003e job=\"ntpdate time1.aliyun.com\" minute=0 hour=*/1' 然后在远程主机中查看cron 周期性任务列表。 vagrant@monitor:~$ crontab -l #Ansible: test cron1 0 */1 * * * ntpdate time1.aliyun.com ","date":"2021-11-27 15:14:00","objectID":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/:0:5","tags":["运维","运维自动化"],"title":"运维自动化 -- Ansible","uri":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/"},{"categories":["运维相关知识"],"content":"6. Ansible copy 实现文件的拷贝 场景分析： 现在是用Ansible copy实现不同主机间的文件同步。使用hostname的方式。 如果要用hostname来进行ssh的连接，需要在/etc/host文件中声明主机的IP和hostname的对应。 root@agent:/tmp# cat /etc/hosts 127.0.1.1 agent agent 127.0.0.1 localhost 192.168.2.6 monitor # The following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters ff02::3 ip6-allhosts 把192.168.2.6 和 monitor的主机名做了对应。然后再再ansible的配置文件的主机列表中加上monitor主机。 root@agent:/tmp# ansible monitor -m copy -a \"src=/tmp/4.sh dest=/tmp/4.sh\" 通过这条命令就实现了主机间的拷贝。 ","date":"2021-11-27 15:14:00","objectID":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/:0:6","tags":["运维","运维自动化"],"title":"运维自动化 -- Ansible","uri":"https://yeliansong.github.io/2020-12-31-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96--ansible/"},{"categories":["运维相关知识"],"content":"运维相关知识","date":"2021-09-28 11:14:00","objectID":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","tags":["运维","操作系统"],"title":"Linux 问题定位及性能优化","uri":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["运维相关知识"],"content":"1.1 平均负载和CPU利用率 这两个通常是衡量系统当前性能的关键指标，但是不能只究一个而放弃另外一个，要两者一起来查看分析。 平均负载：是指单位时间内，系统的运行状态和不可中断状态进程的个数。 CPU使用率：就是指CPU的使用情况，也是我们的常规理解。 好了，细品，其实能感受到两者的一些区别，我们知道，实际上，单核CPU每一个时间点只能运行一个进程，也是最理想的状态，所以如果某一时间点，有多个进程在抢占CPU，实际上这样是不好的，平均负载会升高。不可中断状态是指那些IO进程，比如内核态下，读写硬件，这种进程，系统是不愿意中断的。 所以很好理解了，平均负载高不一定CPU利用率高，比如有很多的IO进程 ，这时候CPU利用率不一定高。而CPU利用率高，平均负载也不一定高。比如单进程中要多个线程在用CPU，这时候CPU利用率也很高，但平均负载并不高。 ","date":"2021-09-28 11:14:00","objectID":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:1","tags":["运维","操作系统"],"title":"Linux 问题定位及性能优化","uri":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["运维相关知识"],"content":"1.2 实例分析 CPU密集型进程 模拟一个CPU密集的进程，单个CPU的使用率达到100%，然后查看平均负载的使用情况。 起了一个进程，将CPU使用率调到100%，然后查看平均负载。 我先来看看cpu的使用情况，来show几个命令的用法。 这个是pidstat命令，可以查看进程CPU的使用，当然也可以用top命令。但是这个命令可以查看内核态和用户态的CPU占用。 用uptime命令查看平均负载。所以可以看到，此时CPU利用率是100%，平均负载并没有很离谱。 IO密集型进程 模拟的是IO进程在一直运行，但是实际上cpu利用率并不会很恐怖，但是平均负载很高 ​ top 命令看不到内核态和用户态分别的系统占用，可以用pidstat 1 来查看进程的用户态和内核态占用 大量进程场景 模拟的是8个进程同时运行的情况，这时候再来看看平均负载和cpu使用率。 可以看到平均负载很高，cpu使用率也很高。 明白了，总结，top，一般用来查看cpu总体使用情况，当然也包括内存消耗；pidstat可以查看每个进程用户态和内核态的cpu消耗。vmstat 看io，cs，内核态和用户态的等待时间。 ","date":"2021-09-28 11:14:00","objectID":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:2","tags":["运维","操作系统"],"title":"Linux 问题定位及性能优化","uri":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["运维相关知识"],"content":"2. CPU上下文切换 CPU上下文切换是Linux系统非常重要的一个性能指标，频繁的上下文切换会影响系统的性能。啥是上下文切换呢，通俗的讲，就是当前进程或线程退出CPU时，系统会把上一个进程或线程的CPU寄存器和程序计数器保存下来，然后加载要运行的进程或线程的CPU寄存器和程序计数器，运行新任务。这一次的切换和保存是影响性能的关键。上下文切换也分为以下几种情况。 进程上下文切换 进程是分为用户态和内核态，内核态是指进程要和Linux内核交互，用户态是不需要和Linux内核交互。所以进程上下文切换也分为两种情况，一种是进程由用户态转到内核态，另外一种是两个进程间的切换。 从用户态到内核态，我们来看看这个干了啥。可以把Linux的运行等级划分为下图 ，Ring 0 是最高等级，权限也是最大，和内核直接交互。Ring 3是用户态，权限有限，只能通过系统调用的方式才能访问内核资源。 从用户态到内核态的一次调用，CPU实际上是做了两次上下文切换，第一次是将用户态的指令位置保存起来，执行内核代码，更新内核指令，跳到内核执行；执行完后，恢复到用户态，是CPU寄存器恢复原来保存的用户态，然后再切换到用户空间。所以发生了两次上下文切换。 进程间内核态的上下文切换相对于系统调用，要保存的消息会更多，比如CPU的进程从一个切换到另外一个，不仅要保存CPU寄存器和程序计算器，同时还要保存虚拟内存、栈等。所以资源消耗和时间会更多。 线程上下文切换 线程是运行于进程的任务，如果进程中只存在1个线程，线程切换可以认为是进程间的 切换 。当进程中有多个线程时，因为多个线程是共享进程的虚拟内存和全局变量的 ，所以一次线程间的切换，CPU只用保存线程的私有数据、寄存器和不共享的资源，所以线程间切换要比进程间切换效率高很多。 中断上下文切换 中断进程的优先级是高于普通进程的，而且中断进程是发生在内核态，所以中断进程打断了用户态的进程，不用保存和恢复这个进程的虚拟内存、全局变量等用户资源。中断上下文，其实只包括内核态中断服务程序执行所需的状态，包括CPU寄存器、内核堆栈、硬件中断参数等。 ","date":"2021-09-28 11:14:00","objectID":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:3","tags":["运维","操作系统"],"title":"Linux 问题定位及性能优化","uri":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["运维相关知识"],"content":"3. 不可中断和僵尸进程 先来回顾下进程的几种状态，这个在平时分析查看时要经常看的。 R：运行状态进程 D：不可中断状态进程，一般是进程在和硬件交互时，不允许交互过程被其他进程或中断打断 Z：僵尸状态。这种是子进程退出后，父进程没有回收子进程，导致处于僵尸状态。一般父进程有一个wait函数来回收子进程的状态 S：可中断状态进程。表示进程因为等待某个事件被系统挂起，可以被唤醒进入就绪和运行状态 T：暂停状态，就是比如进程在运行时，发送一个SIGSTOP信号后，进程处于暂停状体啊，可以通过fg命令恢复 I：处于空闲状态 所以在进行系统分析时，如果有大量的不可状态进程，也就是D状态进程，就要考虑系统的IO问题了。 而对于僵尸进程，正常情况下，并不会影响系统的性能，但是如果大量僵尸进程，可能会把系统的PID号占用完，僵尸进程的清理，可以杀掉父进程 或者等init进程回收。 ","date":"2021-09-28 11:14:00","objectID":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:4","tags":["运维","操作系统"],"title":"Linux 问题定位及性能优化","uri":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["运维相关知识"],"content":"4. 分析CPU的性能指标 这个也是实操部分最关键的，就是出现CPU问题了，可以从哪些角度去分析，第一，肯定是CPU使用率，CPU使用率又包括用户CPU，内核CPU，等待IO，中断，窃取CPU，客户CPU。第二，就是上下文切换。第三，就是平均负载。第四，CPU缓存的命中率。CPU和内存之间是有缓存，通常会把热点数据写到缓存中，缓存的命中率能很大程度提高CPU的性能。 来简单说下自愿和非自愿的上下文切换。 自愿上下文切换：是指进程无法获取所需资源，导致的上下文切换。比如IO，内存等资源不足。 非自愿上下文切换：进程间时间片已用完，被系统强制调度，进而发生的上下文切换 ","date":"2021-09-28 11:14:00","objectID":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:5","tags":["运维","操作系统"],"title":"Linux 问题定位及性能优化","uri":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["运维相关知识"],"content":"5. 工具 ","date":"2021-09-28 11:14:00","objectID":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:6","tags":["运维","操作系统"],"title":"Linux 问题定位及性能优化","uri":"https://yeliansong.github.io/2020-12-13-linux-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["运维相关知识"],"content":"运维相关知识","date":"2021-07-29 11:14:00","objectID":"https://yeliansong.github.io/2020-11-07-prometheus--grafana/","tags":["运维","网络"],"title":"Prometheus + Grafana","uri":"https://yeliansong.github.io/2020-11-07-prometheus--grafana/"},{"categories":["运维相关知识"],"content":"1. 背景介绍 1.1 Prometheus 中文是普罗米修斯，光听名字就感觉很有范，是很厉害的东西。让我来说说普罗米修斯的故事，他是雅典神话中的人物，传说就是他捏造了人形，雅典娜给每个人形赋予了灵魂。宙斯是禁止人类用火，这哥们看到人类处于困苦中，就从阿波罗手里盗取了火，因此触犯了宙斯，之后宙斯就将他关在高加索山的悬崖上，并且每天放出一只恶鹰去啄他的肝，又让他的肝每天都能长出来，让他承受各种痛苦。这神话还挺有意思，所以可以看到普罗米修斯是人类守护神，他来承受各种苦难 ，守护人类。所以今天说的这个东西也是这个功能，是一个性能监控工具，他是基于时间序列的一套开源的监控\u0026报警用 Go语言写的一套系统。 它是基于HTTP协议抓取被监控点的状态信息，所以支持面就比较广，任何支持HTTP协议的组件都可以用它来作为被监控点，所以也广泛被用于docker，k8s和mesos环境的监控。输出被监控组件信息的HTTP接口是exporter，目前很多互联网公司常用的组件都可以直接使用exporter。 1.2 Grafana 用于可视化大型测量数据的开源程序，提供了强大，优雅的方式去创建、共享、浏览 数据。Grafana和Prometheus配合使用，用图形化界面的方式去展示服务的运行情况。 ","date":"2021-07-29 11:14:00","objectID":"https://yeliansong.github.io/2020-11-07-prometheus--grafana/:0:1","tags":["运维","网络"],"title":"Prometheus + Grafana","uri":"https://yeliansong.github.io/2020-11-07-prometheus--grafana/"},{"categories":["运维相关知识"],"content":"2. 实战操练 我是用的vagrant + virtual Box的方式起了三个instance，中间的过程也是一波三折，主要开始是对vagrant不太熟悉，其实vagrant是对开发环境的隔离，和docker有点像，通过box镜像的方式来隔离不同的开发环境。在使用vagrant的时候把网络配置复习了一下，主要是NAT，桥接，host-only，交换机和路由器的区别。 先来说说交换机和路由器的区别吧，这个应该是经常遇到，首先这两个在OSI七层模型中所处的层级是不一样，交换机是处于第二层，数据链路层，而路由器是处于第三层，网络层。交换机是通过物理地址的方式去确定数据的目的地址，路由器是通过网络ID号来寻址。两者的不同方式注定了功能的不同。交换机可以理解为多了更多的LAN 口，每个LAN口的网络互不干扰，路由器恰好相反，是多个LAN口共用一个总的网络端口，所以是共用网络带宽。 NAT： 网络地址转换，是虚拟机通过NAT的功能，通过宿主机所在的网络来访问公网。NAT模式下 ，局域网的其他主机不能访问虚拟机 ，虚拟机可以访问局域网的所有主机。 桥接： 是本地的物理网卡和虚拟网卡通过虚拟交换机进行桥接，虚拟交换机相当于现实网络中的交换机。 host-only： 虚拟网络是在一个全封闭的网络，唯一能访问的就是主机。 总共是起了三个instance，一个是安装prometheus，一个安装granfan，一个是安装node_exporter. 安装和启动prometheus wget https://github.com/prometheus/prometheus/releases/download/v2.7.1/prometheus-2.7.1.linux-amd64.tar.gz tar -xvzf prometheus-2.7.1.linux-amd64.tar.gz -C /usr/local/ mv prometheus-2.7.1.linux-amd64 prometheus ./prometheus --config.file=\"prometheus.yml\" \u0026 (后台运行) lsof -i:9090 （列出端口进程） 弄完后，就启动了prometheus， 占用的端口是9090端口，也就开始了性能的监控。 设置target就是监控的目标，默认情况下监控目标是自己，也可以设置其他的node节点进行监控。 安装和启动node_exporter节点 curl -OL https://github.com/prometheus/node_exporter/releases/download/v0.15.2/node_exporter-0.15.2.darwin-amd64.tar.gz tar -xzf node_exporter-0.15.2.darwin-amd64.tar.gz nohup /usr/local/node_exporter/node_exporter 这个就启动了node_exporter，进去后也是可以看到，实际上就是一堆下图这种日志。 这些日志是可以被prometheus 调用和展示的。 Granfan 安装和启动 这个是一个图形化界面的性能监控工具，安装和启动也是非常简单。 sudo apt-get install grafana service grafana-server start 通过Grafana可以用dashboard把普罗米修斯添加到监控中。 总体来说，还是比较简单。 ","date":"2021-07-29 11:14:00","objectID":"https://yeliansong.github.io/2020-11-07-prometheus--grafana/:0:2","tags":["运维","网络"],"title":"Prometheus + Grafana","uri":"https://yeliansong.github.io/2020-11-07-prometheus--grafana/"},{"categories":["运维相关知识"],"content":"3. k8s 和 prometheus， Granfan结合的实战 https://www.qikqiak.com/post/kubernetes-monitor-prometheus-grafana/ 这篇博文也是一个很好的k8s和prometheus Granfan相结合 的例子。 ","date":"2021-07-29 11:14:00","objectID":"https://yeliansong.github.io/2020-11-07-prometheus--grafana/:0:3","tags":["运维","网络"],"title":"Prometheus + Grafana","uri":"https://yeliansong.github.io/2020-11-07-prometheus--grafana/"},{"categories":["运维相关知识"],"content":"4. Prometheus 常见的问题 https://www.ershicimi.com/p/b27a4437ff01832f1832c563a8a00437 ","date":"2021-07-29 11:14:00","objectID":"https://yeliansong.github.io/2020-11-07-prometheus--grafana/:0:4","tags":["运维","网络"],"title":"Prometheus + Grafana","uri":"https://yeliansong.github.io/2020-11-07-prometheus--grafana/"},{"categories":["运维相关知识"],"content":"运维相关知识","date":"2021-05-13 11:14:00","objectID":"https://yeliansong.github.io/2020-11-13-nginx-practice/","tags":["运维","网络"],"title":"Nginx Practice","uri":"https://yeliansong.github.io/2020-11-13-nginx-practice/"},{"categories":["运维相关知识"],"content":"1. 目的 这篇总结是来回顾加实操Nginx的相关操作。包括Nginx三大特性：负载均衡，反向代理和动静分离。最后利用Nginx来模拟一个高可用场景，加深对Nginx的认识。 ","date":"2021-05-13 11:14:00","objectID":"https://yeliansong.github.io/2020-11-13-nginx-practice/:0:1","tags":["运维","网络"],"title":"Nginx Practice","uri":"https://yeliansong.github.io/2020-11-13-nginx-practice/"},{"categories":["运维相关知识"],"content":"2. 基本概念 2.1 Nginx说明 Nginx是一个http的反向代理web服务器，在并发能力上表现很好，能承受高达50000个并发数。所以也是深受很多公司青睐。包括百度，京东，新浪，腾讯，淘宝等。 2.2 反向代理 和 正向代理 正向代理是代理客户端，服务端对于不同客户端的请求是无感的。一个比较好的例子就是VPN的使用 ，比如我们翻墙使用google，实际上就是一个正向代理，用户相当于还是访问google网址，但是实际上是发给了VPN服务器，由VPN服务器来和Google进行交互通信，再把内容返还给客户端。正向代理需要配置客户端浏览器。 反向代理刚好相反，是用来代理服务端。客户端对于服务端是无感的，比如用户要访问服务端的多台tomcat服务器，可以通过访问反向代理服务器的方式，然后由反向代理服务器和 tomcat进行通信，把内容返回给客户端。所以反向代理是配置服务端。 2.3 负载均衡 负载均衡是相当于通过负载均衡服务器，来把客户端的请求根据负载均衡配置，来分配到各个服务器。 2.4 动静分离 动静分离相当于是把服务端的动态资源和静态资源分开，用nginx来指向不同的服务器。 ","date":"2021-05-13 11:14:00","objectID":"https://yeliansong.github.io/2020-11-13-nginx-practice/:0:2","tags":["运维","网络"],"title":"Nginx Practice","uri":"https://yeliansong.github.io/2020-11-13-nginx-practice/"},{"categories":["运维相关知识"],"content":"3. 环境安装 3.1 Nginx 安装 apt-get install nginx root@agent:/tmp/8081/apache-tomcat-9.0.39/webapps# nginx -t nginx: [warn] conflicting server name \"192.168.2.5\" on 0.0.0.0:80, ignored nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful 主要是配置nginx.conf文件。nginx的默认运行端口是80端口。 3.2 tomcat安装 直接下载tomcat压缩文件，然后放到指定路径下，直接解压。需要安装JDK运行。tomcat的运行是在bin路径下，执行sh文件。tomcat的默认运行端口是8080端口。 sudo add-apt-repository ppa:openjdk-r/ppa sudo apt-get update sudo apt install openjdk-11-jdk 3.3 keepalived 安装 apt-get install keepalived ","date":"2021-05-13 11:14:00","objectID":"https://yeliansong.github.io/2020-11-13-nginx-practice/:0:3","tags":["运维","网络"],"title":"Nginx Practice","uri":"https://yeliansong.github.io/2020-11-13-nginx-practice/"},{"categories":["运维相关知识"],"content":"4. 反向代理 Practice 通过Nginx来代理tomcat服务器，我的虚拟机ip是192.168.2.5, 在Nginx配置文件中监听9001端口，同时Nginx来代理tomcat的8080和8081两个端口。在8080中创建edu文件和html文件，8081中创建vod文件夹和html文件，通过192.168.2.5:9001:/edu/a.html 和 192.168.2.5:9001:/vod/a.html来分别访问两个tomcat服务器。 主要是nginx.conf的配置，下面就是配置说明。还有tomcat的8081 服务器的配置文件要修改默认监听端口8080为8081。 server { listen 9001; server_name 192.168.2.5; location ~ /edu/ { proxy_pass http://127.0.0.1:8080; } location ~ /vod/ { proxy_pass http://127.0.0.1:8081; } } Location ~ 是用来判断是否存在，proxy_pass 是用来指向tomcat服务器。这个block是在nginx.conf的http block中配置。通过这个实验就可以看到Nginx的反向代理了。Nginx代理两个tomcat服务器，用户只用访问9001端口即可访问不同的服务器。 ","date":"2021-05-13 11:14:00","objectID":"https://yeliansong.github.io/2020-11-13-nginx-practice/:0:4","tags":["运维","网络"],"title":"Nginx Practice","uri":"https://yeliansong.github.io/2020-11-13-nginx-practice/"},{"categories":["运维相关知识"],"content":"5. 负载均衡 负载均衡是有三种配置方式，每一种都来试下。这一次是把8081下的服务器也创建一个edu文件夹和a.html文件，浏览器输入192.168.2.5:80/edu/a.html 来根据负载均衡访问不同的tomcat服务器。 轮询 每个请求逐一分配到不同的tomcat服务器。相当于机会是均等的。配置如下： upstream myserver { server 192.168.2.5:8080; server 192.168.2.5:8081; } server { listen 80; server_name 192.168.2.5; location / { proxy_pass http://myserver; } } 这样的话，当请求来时，会轮巡去访问两台tomcat服务器。 weight方式 可以给每台tomcat服务器分配权重，请求会更具权重动态的落到不同的服务器。 upstream myserver { server 192.168.2.5:8080 weight=5; server 192.168.2.5:8081 weight=10; } server { listen 80; server_name 192.168.2.5; location / { proxy_pass http://myserver; } } 这样配置后，请求会根据权重，概率性的落到两台服务器。 Ip_hash 方式 这个是指请求会只落到第一次访问的服务器，不会改到其他服务器，这种可以解决session问题。 upstream myserver { ip_hash; server 192.168.2.5:8080 weight=5; server 192.168.2.5:8081 weight=10; } server { listen 80; server_name 192.168.2.5; location / { proxy_pass http://myserver; } } ","date":"2021-05-13 11:14:00","objectID":"https://yeliansong.github.io/2020-11-13-nginx-practice/:0:5","tags":["运维","网络"],"title":"Nginx Practice","uri":"https://yeliansong.github.io/2020-11-13-nginx-practice/"},{"categories":["运维相关知识"],"content":"6. 动静分离 这种是指把动态资源和静态资源区分开，放在不同的位置，比如数据库查找，属于动态资源，可以放在tomcat中，而静态页面这种可以放在nginx中，根据不同的指向去访问这些资源。就不操作了。 ","date":"2021-05-13 11:14:00","objectID":"https://yeliansong.github.io/2020-11-13-nginx-practice/:0:6","tags":["运维","网络"],"title":"Nginx Practice","uri":"https://yeliansong.github.io/2020-11-13-nginx-practice/"},{"categories":["运维相关知识"],"content":"7. 高可用模拟 Nginx的高可用是指，用两台nginx服务器来做主从服务，当主服务器宕机后，可以自动切换到从服务器。Nginx的切换和监控是由keepalived 来实现，在keepalived中会定义一个脚本，一直去监控 nginx线程的状态，一旦状态变化时，会切换到另一个从服务器。 上面就是整个流程图 ，虚拟ip 192.168.2.50 是keepalived设置的一个虚拟ip，有一个nginx_check.sh 的脚本，会每隔2s去运行下这个脚本, 这个脚本是用来检测nginx线程的，如果没有nginx线程，会kill掉keepalive，服务会导向到从服务器上 。从服务器也是需要一样的配置，只是把 state改成MASTER。 vrrp_script chk_http_port { script \"/etc/keepalived/nginx_check.sh\" interval 2 weight 2 } vrrp_instance inside_VI_1 { state BACKUP #指定那个为master，那个为backup，如果设置了nopreempt这个值不起作用，主备考priority决定 interface eth1 #设置实例绑定的网卡 virtual_router_id 50 #VPID标记 priority 90 #优先级，高优先级竞选为master advert_int 1 #检查间隔，默认1秒 authentication { #设置认证 auth_type PASS #认证方式 auth_pass 111111 #认证密码 } virtual_ipaddress { #设置vip 192.168.2.50 } } # !/bin/bash A= 'ps -C nginx -no-header | wc -l' if [ $A -eq 0 ];then /usr/sbin/nginx sleep 2 if [ 'ps -C nginx --no-header | wc -l' -eq 0 ];then killall keepalived fi fi upstream myserverkeepalived { server 192.168.2.50:8080; server 192.168.2.50:8081; } server { listen 80; server_name 192.168.2.50; location / { proxy_pass http://myserverkeepalived; } } 通过192.168.2.50:/edu/a.html 去 访问，默认情况下是用的master的nginx。我们可以把master的nginx down掉，服务还是可以继续访问，这个时候用的从的nginx。 ","date":"2021-05-13 11:14:00","objectID":"https://yeliansong.github.io/2020-11-13-nginx-practice/:0:7","tags":["运维","网络"],"title":"Nginx Practice","uri":"https://yeliansong.github.io/2020-11-13-nginx-practice/"},{"categories":["运维相关知识"],"content":"8. Nginx 的基本原理 Nginx的架构是一个master的主进程作为守护进程 启动，多个 work进程附属于master进程，结构如下图。每个 work而进程相当于反向代理服务器。各个work进程通过竞争来抢夺请求。 这种方式的好处： 支持热部署。当nginx.conf有改动时，即使有work进程在处理事务，也不影响。config file会同步到未进行事务的work进程，待任务完成后，再同步。 各个work进程不用加锁而实现独立运行，节省了加锁的开销。 每个work支持的最大连接数是4个，worker的最适宜个数和cpu核数保持一致最好。 ","date":"2021-05-13 11:14:00","objectID":"https://yeliansong.github.io/2020-11-13-nginx-practice/:0:8","tags":["运维","网络"],"title":"Nginx Practice","uri":"https://yeliansong.github.io/2020-11-13-nginx-practice/"},{"categories":["运维相关知识"],"content":"9. 附件 1）nginx.conf user www-data; worker_processes 4; pid /run/nginx.pid; events { worker_connections 768; # multi_accept on; } http { ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; root@monitor:/etc/nginx# root@monitor:/etc/nginx# root@monitor:/etc/nginx# cat nginx.conf user www-data; worker_processes 4; pid /run/nginx.pid; events { worker_connections 768; # multi_accept on; } http { ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable \"msie6\"; upstream myserverkeepalived { server 192.168.2.50:8080; server 192.168.2.50:8081; } server { listen 80; server_name 192.168.2.50; location / { proxy_pass http://myserverkeepalived; } } upstream myserver { server 192.168.2.6:8080; server 192.168.2.6:8081; } server { listen 80; server_name 192.168.2.6; location / { proxy_pass http://myserver; } } server { listen 80; server_name 192.168.2.6; location / { root html; proxy_pass http://127.0.0.1:8080; index index.html index.html; } } server { listen 9001; server_name 192.168.2.6; location ~ /edu/ { proxy_pass http://127.0.0.1:8080; } location ~ /vod/ { proxy_pass http://127.0.0.1:8081; } } # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; ## # nginx-naxsi config ## # Uncomment it if you installed nginx-naxsi ## #include /etc/nginx/naxsi_core.rules; ## # nginx-passenger config ## # Uncomment it if you installed nginx-passenger ## #passenger_root /usr; #passenger_ruby /usr/bin/ruby; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } #mail { # # See sample authentication script at: # # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript # # # auth_http localhost/auth.php; # # pop3_capabilities \"TOP\" \"USER\"; # # imap_capabilities \"IMAP4rev1\" \"UIDPLUS\"; # # server { # listen localhost:110; # protocol pop3; # proxy on; # } # # server { # listen localhost:143; # protocol imap; # proxy on; # } #} keepalived.conf global_defs { notification_email { #指定keepalived在发生切换时需要发送email到的对象，一行一个 monitor@3evip.cn } notification_email_from monitor@3evip.cn #指定发件人 smtp_server stmp.3evip.cn #指定smtp服务器地址 smtp_connect_timeout 30 #指定smtp连接超时时间 router_id LVS_DEVEL #运行keepalived机器的一个标识 } vrrp_sync_group VG_1{ #监控多个网段的实例 group { inside_network #实例名 outside_network } notify_master /path/xx.sh #指定当切换到master时，执行的脚本 netify_backup /path/xx.sh #指定当切换到backup时，执行的脚本 notify_fault \"path/xx.sh VG_1\" #故障时执行的脚本 notify /path/xx.sh smtp_alert #使用global_defs中提供的邮件地址和smtp服务器发送邮件通知 } vrrp_script chk_http_port { script \"/etc/keepalived/nginx_check.sh\" interval 2 weight 2 } vrrp_instance inside_VI_1 { state BACKUP #指定那个为master，那个为backup，如果设置了nopreempt这个值不起作用，主备考priority决定 interface eth1 #设置实例绑定的网卡 virtual_router_id 50 #VPID标记 priority 90 #优先级，高优先级竞选为master advert_int 1 #检查间隔，默认1秒 authentication { #设置认证 auth_type PASS #认证方式 auth_pass 111111 #认证密码 } virtual_ipaddress { #设置vip 192.168.2.50 } } virtual_server 192.168.36.99 80 { delay_loop 6 #健康检查时间间隔 lb_algo rr #lvs调度算法rr|wrr|lc|wlc|lblc|sh|dh lb_kind DR #负载均衡转发规则NAT|DR|RUN persistence_timeout 5 #会话保持时间 protocol TCP #使用的协议 persistence_granularity \u003cNETMASK\u003e #lvs会话保持粒度 virtualhost \u003cstring\u003e #检查的web服务器的虚拟主机（host：头） sorry_server\u003cIPA","date":"2021-05-13 11:14:00","objectID":"https://yeliansong.github.io/2020-11-13-nginx-practice/:0:9","tags":["运维","网络"],"title":"Nginx Practice","uri":"https://yeliansong.github.io/2020-11-13-nginx-practice/"},{"categories":["运维相关知识"],"content":"运维相关知识","date":"2021-04-19 15:14:00","objectID":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/","tags":["运维","网络"],"title":"HTTP详解","uri":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/"},{"categories":["运维相关知识"],"content":"这份总结可能不是覆盖所有的HTTP知识点，只是按照我自己理解的，然后结合网上资料，进行总结。 ","date":"2021-04-19 15:14:00","objectID":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/:0:0","tags":["运维","网络"],"title":"HTTP详解","uri":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/"},{"categories":["运维相关知识"],"content":"1. 什么是HTTP HTTP(hypertext transport protocol), 就是超文本传输协议，文本可以理解为字符，文字，也可以是音视频等等。超文本就不是单纯的文本文件了，而是更加复杂的多种文件的混合。 其实也是非常好理解了，HTTP实际上还是一种应用层的协议，好了，来复习下网络的七层模型吧。应用层，表示层，会话层，传输层，网络层，链路层，物理层。 这个图还是很全面的，概述了整个七层模型的每一层功能已经范围。而HTTP是属于应用层的协议。 ","date":"2021-04-19 15:14:00","objectID":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/:0:1","tags":["运维","网络"],"title":"HTTP详解","uri":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/"},{"categories":["运维相关知识"],"content":"2. 不同版本的HTTP 这个在面试的时候还是有问到，所以也说说这个吧。目前，http的版本共经历了四次的变化： HTTP 0.9 –\u003e HTTP 1.0 –\u003e HTTP 1.1 –\u003e HTTP 1.2 HTTP 0.9 第一个版本，这个版本只支持GET请求，且只能相应HTML字符串能力。 HTTP 1.0 新增了post， delete， put。 且新增了请求头和响应头的概念，并且指定了HTTP协议的版本号，状态码，编码等内容，同时还支持传输图片，音视频，二进制等内容。 HTTP 1.1 新增了长链接，新增管道化处理，缓存处理和断点传输。管道化，就是可以同时发送多个HTTP请求，而不用一个一个等待响应。断点续传，客户端会记录当前的下载进度，在需要续传时，再通知服务器本次需要下载的内容片段。长链接下面再详细说下。 2.1 长链接和短链接的区别 其实也非常好理解了，长链接就是客户端和服务端建立连接后，就保持这个连接状态，不用一次请求结束后断开连接；短连接就相反，每次请求结束后就断开连接。所以他们的优缺点就非常明显。 长连接更好的节省了连接和关闭的时间，减少浪费。但是也会存在一个问题，就是随着连接数的增多，而客户端和服务端的连接一直在保持，会带来一些问题，服务端肯定会吃不消，对于这种情况呢，也有解决的方法，当连接数到达一定数后，服务端可以主动关闭一些长时间没有读写的事件连接。相对于来说，短连接的问题会更加严重，因为每次请求都要建立连接，然后在断开连接，如果对于那种频繁请求的服务，就会极大的占用资源。所以不管是长连接还是短连接，都是根据具体的需求来定。 ","date":"2021-04-19 15:14:00","objectID":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/:0:2","tags":["运维","网络"],"title":"HTTP详解","uri":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/"},{"categories":["运维相关知识"],"content":"3. HTTP的一些元素 3.1 HTTP 报文 这个就是HTTP报文的格式，上面一个是请求体，下面是返回的东西，具体的如下所示： 3.2 URI URI和URL啥区别，URI是用来干啥的。 URI是统一资源标识符。它是用来定义要访问的服务器的地址。 URI是包含URL和URN的。 3.3 Cookie 因为HTTP是无状态的，啥意思呢，就是协议对于事务处理是没有记忆能力的，服务器端也不知道客户端的具体情况。Cookie的引入就是为了解决这个问题，cookie是有浏览器来负责存储的，而不是操作系统负责，换一个服务器，就不知道了。 3.4 session Session是用来跟踪客户端的，就是用来区分特定的客户端，但是它的实现是通过cookie来实现的。什么意思呢，就是客户端发送请求是，会有一个cookie，然后服务端如果想要跟踪这个客户端的信息，就会在cookie里记录一个session id，下次这个客户再请求时，会用上这个session id，而服务端返还信息时，也会根据这个session id来找到客户端。可以说是相辅相成吧。 ","date":"2021-04-19 15:14:00","objectID":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/:0:3","tags":["运维","网络"],"title":"HTTP详解","uri":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/"},{"categories":["运维相关知识"],"content":"4. HTTPS 所有人都知道，HTTPS相较于HTTP是更加安全的通信协议，HTTP的报文内容是明文，而HTTPS会对报文进行加密传输，所以安全性会更好。 HTTPS相较于HTTP的区别在下图。 HTTPS = HTTP + TLS/SSL. HTTPS在建立通信之前是有一个握手的过程，就是客户端和服务端建立连接前，要通过对称和非对称加密算法进行加密，只有当客户端和服务端都验证通过后，才能建立连接，传输报文。 具体的过程可以看下图。 具体流程可以如下： 浏览器先是将自己支持的加密规则发给网站，网站会选出一套加密算法和HASH算法，并将自己的身份信息以证书的形式发回给浏览器，证书里包含网站地址，公钥，以及证书的颁发机构等信息。 浏览器收到证书后，会生生成一串随机数，用公钥对随机数进行加密，用约定好的HASH算法计算握手信息，并用随机数进行加密，然后发给客户端。 客户端收到后先用私钥进行解密，取出随机数密码，然后在用随机数密码进行握手信息的解密，验证HASH算法是否和第一次发进来的一致，再使用密码加密一段握手信息，发给浏览器。 浏览器解密计算握手信息的HASH，如果和服务端一致整个过程结束，之后所有的通信数据都将基于加密算法进行加密。 ","date":"2021-04-19 15:14:00","objectID":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/:0:4","tags":["运维","网络"],"title":"HTTP详解","uri":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/"},{"categories":["运维相关知识"],"content":"5. HTTPS 和HTTP的区别 HTTPS需要SSL证书，用于加密和验证握手信息 HTTP是超文本传输协议，信息都是明文传输，HTTPS则是具有安全性的SSL加密传输 使用的端口不同，HTTPS是443端口，HTTP是80端口 http的连接很简单，但是https建立连接传输数据需要SSL认证。 ","date":"2021-04-19 15:14:00","objectID":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/:0:5","tags":["运维","网络"],"title":"HTTP详解","uri":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/"},{"categories":["运维相关知识"],"content":"6. TCP 和 UDP 这个也是面试常考的考点，两者的区别也很明显。 TCP是面向连接的，UDP是无连接的，TCP的传输更加可靠，有有序序列来保证数据的完整。UDP的可靠性没有这么强，可能会有数据的丢失。 TCP的速度比较慢，因为要创建连接，保证消息的可靠性和有序性，需要做额外的很多工作；UDP更适合对速度比较敏感的应用。 ","date":"2021-04-19 15:14:00","objectID":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/:0:6","tags":["运维","网络"],"title":"HTTP详解","uri":"https://yeliansong.github.io/2020-5-30-http-%E8%AF%A6%E8%A7%A3/"},{"categories":["运维相关知识"],"content":"运维相关知识","date":"2021-03-28 11:14:00","objectID":"https://yeliansong.github.io/2020-05-25-nginx/","tags":["运维","网络"],"title":"Nginx","uri":"https://yeliansong.github.io/2020-05-25-nginx/"},{"categories":["运维相关知识"],"content":"1.Nginx是什么？ 从Google搜索结果来看，Nginx是一个免费、开源、高性能的HTTP服务器和反向代理，同时也是一个IMAP/POP3代理服务器。 Nginx 以其高性能、稳定性、丰富的功能集、简单的配置和低资源消耗而闻名。 Nginx 最多支持 50000 个并发应用程序。 ","date":"2021-03-28 11:14:00","objectID":"https://yeliansong.github.io/2020-05-25-nginx/:0:1","tags":["运维","网络"],"title":"Nginx","uri":"https://yeliansong.github.io/2020-05-25-nginx/"},{"categories":["运维相关知识"],"content":"2. 正向和反向代理 转发代理是客户端和目标服务器之间的代理服务器。 为了从原始服务器获取内容，客户端向代理服务器发送请求，并指定目标服务器，然后代理传输到目标服务器，并将获取的内容返回给客户端。 这样，如果您可以直接访问，则无法访问 www.google.com。 但您可以使用转发代理。 在正向代理中，真正的客户端对服务器来说是不可见的。 最终的结果是你可以通过代理服务器访问www.google.com网站。 这就是转发代理。 好的，现在我们可以比较反向代理了。 事实恰恰相反。 对于客户端来说，反向代理就像目标服务器一样，客户端不需要进行任何设置。 客户端向反向代理发送请求，然后反向代理判断请求的去向，并将请求转发给客户端。 和上面一样，反向代理就是代理服务器，很常见。 例如，你每天访问www.google.com，它实际上是一个反向代理，你不知道真实的服务器地址。 只需显示代理地址即可。 ","date":"2021-03-28 11:14:00","objectID":"https://yeliansong.github.io/2020-05-25-nginx/:0:2","tags":["运维","网络"],"title":"Nginx","uri":"https://yeliansong.github.io/2020-05-25-nginx/"},{"categories":["运维相关知识"],"content":"3.负载均衡 负载均衡，是指将负载均衡分配给多个作业单元运行，以协同完成工作任务。 负载均衡建立在原有的网络结构之上，为扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、增加网络可用性和灵活性提供了一种透明且廉价且有效的方法。 上面的架构很常见。 它可以通过负载均衡来平衡互联网请求。 它是在高并发的情况下使用的。 ","date":"2021-03-28 11:14:00","objectID":"https://yeliansong.github.io/2020-05-25-nginx/:0:3","tags":["运维","网络"],"title":"Nginx","uri":"https://yeliansong.github.io/2020-05-25-nginx/"},{"categories":["运维相关知识"],"content":"4.热备 在这张图中，我们可以看到一个负载平衡应用程序。 可用率很高。 有 2 台负载均衡服务器，包括主服务器和辅助服务器。 主从通过健康检查进行通信。 如果主服务器宕机了，那么辅助服务器就无法与主服务器联系，就会知道出了问题。 流量将转发到辅助服务器而不是主服务器。 这样，就可以保证系统的正常运行。 ","date":"2021-03-28 11:14:00","objectID":"https://yeliansong.github.io/2020-05-25-nginx/:0:4","tags":["运维","网络"],"title":"Nginx","uri":"https://yeliansong.github.io/2020-05-25-nginx/"},{"categories":["运维相关知识"],"content":"5.动静分离 动静分离是让动态网站中的动态网页按照一定的规则区分出不变的资源和不断变化的资源。 Nginx 可以通过配置文件来分离资源。 通过这种方式可以提高性能。 ","date":"2021-03-28 11:14:00","objectID":"https://yeliansong.github.io/2020-05-25-nginx/:0:5","tags":["运维","网络"],"title":"Nginx","uri":"https://yeliansong.github.io/2020-05-25-nginx/"},{"categories":["运维相关知识"],"content":"6. 最佳实践 可以参考网站。 ","date":"2021-03-28 11:14:00","objectID":"https://yeliansong.github.io/2020-05-25-nginx/:0:6","tags":["运维","网络"],"title":"Nginx","uri":"https://yeliansong.github.io/2020-05-25-nginx/"},{"categories":["算法-数据结构"],"content":"数据结构-算法","date":"2021-02-14 11:19:00","objectID":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/","tags":["数据结构","算法"],"title":"树","uri":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/"},{"categories":["算法-数据结构"],"content":"1. 概念 说到树，就得先说下线性结构和非线性结构。数据结构存在的意义就是去构造一组相互关联的数据模型，然后再配合算法，一起解决计算机中一些运行一些需要耗时的操作。线性和非线形就是非常重要的两种数据模型。 线性结构： 数据元素关系是一对一的，数据元素是首尾呼应 栈 队列 线性表 数组 串 非线形结构： 元素之间关系不是一对一，每个元素可能与零个或多个其他数据有关系 二维数组 多维数组 广义表 树 图 所以树的概念就非常明了了，是一种非线形结构，有一个根，根下的每一层都是子节点，也是构成一棵树，典型的递归。这种数据逻辑结构其实使用的非常广，比如在数据库系统中数据信息的组织形式，操作系统中文件系统的分层管理等等，还有我们写代码，一层一层的也是这种结构，使用这种结构也是非常明显的一个好处，便于搜索查找。 ","date":"2021-02-14 11:19:00","objectID":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/:0:1","tags":["数据结构","算法"],"title":"树","uri":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/"},{"categories":["算法-数据结构"],"content":"2. 二叉树 ​ 二叉树是一种比较简单的树形结构，就是每个节点最多有两个子树，最少是0个。 ","date":"2021-02-14 11:19:00","objectID":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/:0:2","tags":["数据结构","算法"],"title":"树","uri":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/"},{"categories":["算法-数据结构"],"content":"3. 二叉树的遍历 3.1 构造二叉树 ​ 代码演示。 3.2 二叉树遍历 前序遍历 中序遍历 后续遍历 代码演示 3.4 求二叉树的最大值 ​ 代码演示 3.5 求二叉树的最大深度 ​ 代码演示 ","date":"2021-02-14 11:19:00","objectID":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/:0:3","tags":["数据结构","算法"],"title":"树","uri":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/"},{"categories":["算法-数据结构"],"content":"4. 二叉搜索树（BST） 4.1 概念 也叫二叉查找树，BST, Binary Search Tree, 它的要求是： 左子树下的节点值小于节点值，右子树下的每个节点值大于节点值。 为啥要搞出这玩意，其实很明显，能够提高查找的效率，其实它就是一个二分查找。它的时间复杂度是依赖于二叉树的拓扑结构，也就是和它的深度有关。最差的情况就是O(n), 最好的时候就是 O (log2 (n)). 4.2 构造二叉搜索树 比如给一组数组，arr[] = {6, 4, 5, 9, 2, 3, 7, 8, 1}, 构造一棵二叉搜索树。 代码演示。 构造二叉树的中序遍历是数组的排序。 4.3 平衡二叉树 刚刚讲了二叉搜索树的时间复杂度是和它的深度有关，深度越深，时间复杂度越高，平衡二叉树来了。 概念： 平衡二叉树(Balanced Binary Tree), 也叫AVL树。 首先，平衡二叉树肯定是一棵二叉搜索树，其次，它的左右两个子树的高度差的绝对值不超过1，而且左右两个子树都是一棵平衡二叉树。 二叉搜索树可以通过平衡因子对搜索树进行调整。 ","date":"2021-02-14 11:19:00","objectID":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/:0:4","tags":["数据结构","算法"],"title":"树","uri":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/"},{"categories":["算法-数据结构"],"content":"5. 深度优先搜索和广度优先搜索 这两种方式都是对树形结构进行遍历的两种方式，一种是深度遍历，一种是依树的层次进行遍历。 5.1 深度优先搜索 （DFS） 深度优先搜索，就是Depth-First-Search, 缩写的DFS算法。二叉树的前序中序后序遍历就是DFS算法。我就不举例子了。 5.2 广度优先搜索 （BFS） 广度优先搜索，就是Breadth-First-Search, 缩写为BFS算法。就是依树的层次进行遍历。 比如这棵树，广度优先搜索，[1, 2, 3, 4, 5, 6, 7]; 代码实现是通过队列来实现。 5.3 DFS 和 BFS 具体实例场景 ","date":"2021-02-14 11:19:00","objectID":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/:0:5","tags":["数据结构","算法"],"title":"树","uri":"https://yeliansong.github.io/2020-11-02-%E6%A0%91/"},{"categories":["算法-数据结构"],"content":"数据结构-算法","date":"2020-12-03 10:14:00","objectID":"https://yeliansong.github.io/2020-05-07-hashmap/","tags":["数据结构","算法"],"title":"HashMap","uri":"https://yeliansong.github.io/2020-05-07-hashmap/"},{"categories":["算法-数据结构"],"content":"1. HashMap出现的背景 这一部分，先从数组和链表的优劣势，来引出散列表和哈希。看一下散列表和哈希相对于前两种，有哪些特点。 1.1 数组的优势劣势 先看看数组的内存结构图。 看这个图，应该很清晰的看到数组的特点和优劣势。 数组的特点是顺序存储，长度的固定长度 数组中查找数据非常方便，可以直接根据索引读取到固定位置的数据 （优势） 数组增加删除数据非常麻烦，需要先对数组进行扩容，然后重新对数组进行赋值 （劣势） 1.2 链表的优势劣势 来看看链表的内存结构图。链表也很多种啊，单向，双向，循环等等，我们拿单链表来说。 上面两张图，第一张是链表的内存结构图，可以看到，链表的结构是有一个数据区和地址区，地址区是依次指向下一个元素。链表的插入和删除操作也非常方便，只用将上一个的地址指向要插入的元素就可以了。所以从链表中我们也可以得到如下的特点。 链表的长度不是固定的，可以根据需要动态的调整 链表的查找会非常麻烦，不能根据索引查找，需要一个个从头到尾去遍历 （劣势） 链表的插入和删除操作非常方便 （优势） 1.3 散列表和哈希 说了这么多，列举了前面两种数据结构的优劣势，有没有一种数据结构可以同时兼具以上两种的优点呢，这个就要说到散列表了。 来看看散列表的结构。 这个就是散列表的内存结构图。可以看一下，分为两部分，左边的紫色部分是一个数组结构，每一个数组中都有一个链表的头指针，右边的绿色部分是一个链表结构，用来解决冲突问题。散列表是集成了数组和链表两种数据结构的特点。 Hash，是一种算法，它的原理是，把任意长度的输入都转算成固定长度的输出。这个映射的方法就是Hash算法。Hash算法有如下的特点： 不能进行反向的推导。就是指不能根据结果来推导出原始的数据 任意微小的原数据的改变都会得到一个不同的结果 Hash算法的执行效率非常高 Hash算法有冲突概率。因为输入空间要远大于输出空间，所以可能会存在不同的输入得到相同的输出问题 ","date":"2020-12-03 10:14:00","objectID":"https://yeliansong.github.io/2020-05-07-hashmap/:0:1","tags":["数据结构","算法"],"title":"HashMap","uri":"https://yeliansong.github.io/2020-05-07-hashmap/"},{"categories":["算法-数据结构"],"content":"2. HashMap原理 2.1 HashMap 的物理结构 前面讲了这么多，HashMap就可以很容易理解了，就是用Hash算法实现的一个散列表。看下图。 就是数组+链表+红黑树结构。 链表是当有冲突元素时会在数组结构中加上链表。 当链表节点数量大于等于8个，而且哈希表的所有元素个数大于64个时，会把链表结构升级为红黑树结构。 2.1 HashMap的插入数据流程 可以看下这张图，这个流程就是数据插入到HashMap的流程。 首先是讲插入的key通过hash算法转成hash值，然后hash值通过扰动函数，使hash值更加的散列，之后在构造出hash的node节点，再根据路由算法，计算这个node节点应该插入到哪个位置。 可以看下这个路由公式，table length是hash数组的长度，一般是2的次方，然后再和hash值进行与元素，得到插入的位置，将这个node插入到hashmap的节点。 2.2 Hash碰撞 前面也讲过了，当两个不同的输入得到了一个相同的hash值，或者根据路由公式，计算出的node节点位置有冲突时，也会引起Hash碰撞。发生Hash碰撞后，会在数组节点形成一个链式表。 2.3 Hash扩容 可以看到，如果Hash数组的大小有限时，会很容易造成Hash碰撞。发生Hash碰撞后，链表的长度就会越来越长，导致的结果就是无法发挥出HashMap的优势，就往链表上靠了。所以为了解决这个问题，就要对Hash进行扩容。扩容后，可以有效的减少碰撞。 ","date":"2020-12-03 10:14:00","objectID":"https://yeliansong.github.io/2020-05-07-hashmap/:0:2","tags":["数据结构","算法"],"title":"HashMap","uri":"https://yeliansong.github.io/2020-05-07-hashmap/"},{"categories":["算法-数据结构"],"content":"3. HashMap源代码分析 3.1 C++ Key-Value 形式的容器 JAVA 的HashMap是用的JDK。 C++ 有很多的key-value形式的容器，map / hash_map / unordered_map / vector_map. Map，是用的红黑树实现，构建map花费的时间比较长。 vector_map 在c++中没有实现，基本思想就是使用vector保存数据，插入完成后进行排序，然后使用二分查找。 hash_map，STL的实现叫做unordered_map， 都是基于hash_table实现的，首先是分配一大片内存，形成很多桶，利用hash函数将key映射到不同的桶中。 hash_map的查找速度比map快，它的查找速度与数据量大小无关，属于常数级别。map的查找速度是log(n)级别。 3.2 HashMap源码 ","date":"2020-12-03 10:14:00","objectID":"https://yeliansong.github.io/2020-05-07-hashmap/:0:3","tags":["数据结构","算法"],"title":"HashMap","uri":"https://yeliansong.github.io/2020-05-07-hashmap/"},{"categories":["生活感悟"],"content":"生活感悟","date":"2020-11-28 19:14:00","objectID":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/","tags":["生活感悟","住房"],"title":"新加坡住房介绍","uri":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/"},{"categories":["生活感悟"],"content":"以下内容仅供参考，不涉及任何投资，具体内容请参考政府官方发布！！！ ","date":"2020-11-28 19:14:00","objectID":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/:0:1","tags":["生活感悟","住房"],"title":"新加坡住房介绍","uri":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/"},{"categories":["生活感悟"],"content":"1. 新加坡居住房屋种类 新加坡的住房分为政府规划建造的HDB组屋，执行共管公寓，以及私人商品房住宅。其中私人商品房住宅又分为有地住宅和非有地住宅（即公寓）。HDB(House\u0026Development Board)建造的组屋和执行共管公寓都是99年地契，私人住宅由私人房地产开发商建造的楼盘有99年,999年和永久地契的差别。 政府组屋 大部分新加坡居民都是买的政府组屋，面向的是新加坡公民和永久居民的福利房。 （1）2房式组屋 ：1 间卧室，实用面积大约45平方米 。 （2）3房式组屋 ：2 间卧室，实用面积大约70平方米。 （3）4房式组屋 ：3 间卧室，实用面积大约80-105平方米。 （4）5房式组屋 ：3 /4间卧室，实用面积大约110-125平方米。 （5）行政公寓 （EA）：3/4 卧室，套内面积大约150平方米。 （6）行政双层公寓（EM） ：同行政公寓一样, 但是双层的。 HDB管辖的公寓 执行共管公寓（EC）：私房地产开发商**开发的商品房，价格比私人商品房便宜，公寓设施几乎相当。只有新加坡公民才可以购买，5年后可以出售给新加坡永久居民，10年后自动私有化成为商品房公寓出售给外国人。 私人公寓 这类是针对外国人，对外国人没有限制。有俱乐部、操场、健身房、游泳池、网球场和烧烤台，有24小时安全监控。 （1）共管公寓（Condo/Apartment）：标准公寓设施。例如游泳池，24小时保安，图书馆，健身房，篮球场，网球场等。 （2）高层公寓（HiRise）：有部分公寓设施，但是可能没有篮球场，一般健身房，24小时保安，游泳池是有的。 （3）低层公寓（LoRise） ：有部分公寓设施。比方说游泳池，健身房。 （4）阶梯公寓（WalkUp）：没有电梯的低层公寓，也没有任何公寓设施。 有地房产 这类就是有私有花园、车库的私人房产，外国人不可以购买，永久居民原则上是不可以购买，对有特殊贡献的人政府审批是可以购买的。 （1）独立式别墅：别墅四边没有与别家相连的墙壁或篱芭，面积400平方米以上，楼高最高三层。 （2）半独立式别墅：房子一边与隔壁住宅肩并肩联接，面积200平方米以上，楼高最高三层。 （3）联体别墅（排屋）：一组住宅肩并肩联接，面积150平方米以上。 （4）角头排屋: 排屋最靠两边的房子。 （5）优质别墅：面积1400平方米以上。新加坡有39个这样的区域。 ","date":"2020-11-28 19:14:00","objectID":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/:0:2","tags":["生活感悟","住房"],"title":"新加坡住房介绍","uri":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/"},{"categories":["生活感悟"],"content":"2. 购买组屋的条件 大部分新加坡居民都会购买组屋，包括永久居民和外国人。但是购买组屋又有很多的身份限制，下面就是根据身份来划分的可以购买的类型，可以根据自己情况按号入座。 下面列举的是家庭两个核心成员，可以是买家+配偶/父母/孩子。 新公民+新公民：所有组屋都可以买，包括BTO新组屋。 新公民+永久居民：所有组屋都可以买，包括BTO新组屋，不需要成为永久居民满3年。 新公民+EP,SP,DP,WP,LTVP…..: 准证的有效期需超过6个月，可以买转售组屋。2013年7月起，也可以向政府申请购买BTO新组屋（限制条件：至少35岁，首次购房，家庭月收入不能超过5000新币，只能申请2房式组屋；房子其实相当于是公民以个人名义购买，不是夫妻双方共有的）。 满3年的永久居民+满3年的永久居民：双方均拥有永久居民身份满 3年，可以买转售组屋 。不可以买BTO组屋。 满3年的永久居民+未满3年的永久居民：不可以买组屋。需等双方永久居民都满3年才可以。 未满3年的永久居民+未满3年的永久居民：不可以买组屋。需等双方永久居民都满3年才可以。 永久居民+EP,SP,DP,WP,LTVP…..:不可以买组屋。 ","date":"2020-11-28 19:14:00","objectID":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/:0:3","tags":["生活感悟","住房"],"title":"新加坡住房介绍","uri":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/"},{"categories":["生活感悟"],"content":"3. 购买BTO(新组屋)的限制 BTO是build to order，预售组屋，它是先售卖再建造的形式，有点像团购的感觉，从申请购买到交房拿钥匙大约需要3-4年的时间。BTO的优势是价格相对于转售组屋会更便宜，还能根据你的情况享受政府补贴，所以大部分人会优先买BTO。但是问题是交房时间较长，而且对身份会比较严苛。 收入限制 4房式或更大的组屋（包括执行共管公寓EC）：家庭收入不能超过每月12000新币，如果是跨代联名（例如和父/母联名）购买组屋，家庭收入顶限则是18000新币。 3房式组屋：非成熟社区组屋，购买时收入顶限是每月6000新币或12000新币，根据不同项目而定。成熟社区组屋的收入顶限则固定在每月12000新币。 转售组屋：无收入限制。 其他限制 购房者至少一方满21岁。 在新加坡或海外没有拥有其他房产，同时在购房前的30个月内，也没有处理过任何本地或海外房产。 没有用新加坡公积金的住房补助金，在新加坡买过其他房子。 ","date":"2020-11-28 19:14:00","objectID":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/:0:4","tags":["生活感悟","住房"],"title":"新加坡住房介绍","uri":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/"},{"categories":["生活感悟"],"content":"4. BTO VS 转售组屋 BTO和转售组屋的价格相当大，同一地区的BTO和转售组屋(相同面积)可能差价在30-50万新币，转售组屋随着房子年限会越来越不值钱，越新的转售组屋价格会越贵。所以可以说BTO是新加坡居民最大的优惠房，如果能买到BTO是一定要买BTO。 上图是queestown 附近转售组屋价格，四房，2015年房子总价在接近80万新币。下面看下BTO差不多相同位置的价格。 四房，价格是在48到53万，可以看到这个还是隔的挺多的。 ","date":"2020-11-28 19:14:00","objectID":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/:0:5","tags":["生活感悟","住房"],"title":"新加坡住房介绍","uri":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/"},{"categories":["生活感悟"],"content":"5. Condo Condo可以说是大部分外国人或新申请上PR的外国人在新加坡置业的最佳选择了，但是Condo也是有它的一些问题。第一个是价格贵，面积不会很大，另外交的税会多。Condo是对居民的身份没有任何要求。 在新加坡，买家需要交纳的买家印花税和额外买家印花税与房价和买主的身份有着密不可分的联系。房价越高，相对应的买家印花税也就越高。 海外人士在购买住宅物业类物业时需缴纳20％额外买家印花税 在卖房时，只需要按照期限，交纳一定比例的印花税即可。在2011年1月14日过后买房的购房者，仅需在购房3年内支付卖方印花税，持3年以上后再卖出就不必再交纳了，这也是新加坡杜绝炒房的一个重要措施。 所以买Condo也是很贵的。 ","date":"2020-11-28 19:14:00","objectID":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/:0:6","tags":["生活感悟","住房"],"title":"新加坡住房介绍","uri":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/"},{"categories":["生活感悟"],"content":"6. 关于在新加坡的投资买房 新加坡的房地产市场和国内相比，真的是管控的太好了，在新加坡投资买房实现财富的增值可以说是非常困难的，政府通过加税，严格限制一套房，增加买房身份限制等等方法来规范买房卖房市场，所以新加坡的房地产市场一直是处于房价稳定状态，没有很多人会想着通过买房卖房来实现财富增值。比较好的一次机会就是政府的新组屋，也就是BTO，这个可以说是在新加坡置业投资的最优选择了，也是政府给民众的最大福利了，但是BTO也是有身份和时间限制，如果有幸能拿到BTO组屋，一定要抓住。 ","date":"2020-11-28 19:14:00","objectID":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/:0:7","tags":["生活感悟","住房"],"title":"新加坡住房介绍","uri":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/"},{"categories":["生活感悟"],"content":"7. 完结 个人是非常欣赏新加坡政府针对居民住房所实行的一系列举措，保证居者有其屋。如果每个人都想着靠投资房子来实现财富的巨大增值，其实是非常不健康的，也会让很多人认为个人的工作奋斗等等没有意义，大家都会去买房投资，年轻人会更加恐慌，也会更加浮躁，最后也形成了一种恶性循环，生活的幸福感也会降低。 ","date":"2020-11-28 19:14:00","objectID":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/:0:8","tags":["生活感悟","住房"],"title":"新加坡住房介绍","uri":"https://yeliansong.github.io/2021-3-14-%E6%96%B0%E5%8A%A0%E5%9D%A1%E4%BD%8F%E6%88%BF%E4%BB%8B%E7%BB%8D/"},{"categories":["CKA考试"],"content":"CKA考试","date":"2020-07-01 09:31:00","objectID":"https://yeliansong.github.io/2020-5-25-cka/","tags":["CKA考试","微服务"],"title":"CKA 证书","uri":"https://yeliansong.github.io/2020-5-25-cka/"},{"categories":["CKA考试"],"content":"1. Certified Kubernetes Administrator ","date":"2020-07-01 09:31:00","objectID":"https://yeliansong.github.io/2020-5-25-cka/:0:1","tags":["CKA考试","微服务"],"title":"CKA 证书","uri":"https://yeliansong.github.io/2020-5-25-cka/"},{"categories":["CKA考试"],"content":"2. The Exam Info ","date":"2020-07-01 09:31:00","objectID":"https://yeliansong.github.io/2020-5-25-cka/:0:2","tags":["CKA考试","微服务"],"title":"CKA 证书","uri":"https://yeliansong.github.io/2020-5-25-cka/"},{"categories":["CKA考试"],"content":"3. Certification Verification Tool You can access this link to verify the certification. Certification Verification Tool ","date":"2020-07-01 09:31:00","objectID":"https://yeliansong.github.io/2020-5-25-cka/:0:3","tags":["CKA考试","微服务"],"title":"CKA 证书","uri":"https://yeliansong.github.io/2020-5-25-cka/"},{"categories":["容器-微服务"],"content":"容器、微服务","date":"2020-05-20 11:14:00","objectID":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/","tags":["容器","微服务"],"title":"Docker网络详解","uri":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/"},{"categories":["容器-微服务"],"content":"我们知道，Docker的核心是资源隔离，Docker相当于是运行在Host 主机上的一个进程，但是这些进程是如何实现彼此的互不干扰，独立运行呢？这个就要说到Docker的CGroup 和 Namespace了。 CGroup全称是Control Group，是用来设置进程使用CPU，内存和IO资源的限额。所以CGroup相当于是用来做资源的控制。Docker的CGroup配置是放在 /sys/fs/cgroup/路径下配置文件里，通过这些配置文件，来设置Docker进程的资源配置。 Namespace是实现Docker的资源隔离，分别对应了6种资源： Mount， UTS， IPC， PID，Network和 User。 Mount Namespace，是可以让容器能独立的拥有自己的文件系统 UTS Namespace， 是让容器有自己的hostname IPC Namespace， 是让自己有自己独享的内存和信号量来实现进程间的通信，而不会与host和其他的容器IPC混在一起 PID，进程ID Network namespace， 让容器拥有自己独立的网卡，IP，路由等资源。 User Namespace， 让容器可以管理自己的用户。 好了，说了这么多的废话，这章来讲解下容器的网络。 容器的网络实际上是分为三种，none，bridge和host。可以通过命令方式看下容器的网络配置。 那个 my_next 是我自己配置的一个bridge网络。这个是在host docker上看到的容器网络几种类型。 ","date":"2020-05-20 11:14:00","objectID":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/:0:0","tags":["容器","微服务"],"title":"Docker网络详解","uri":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/"},{"categories":["容器-微服务"],"content":"1. none 网络 none网络就是什么都没有的网络，挂在这个网络下的就是IO，没有任何其他的网卡。可以看下。 就是通过 –network=none 来配置，可以看下ifconfig就是只有local 的network。 可能有人会问，这种网络有什么作用呢，也不能和外面通信，其实还是有作用的，比如涉及到的一些隐私等可以通过这种方式配置，可以通过这个docker来生成和密钥相关的一些东西，还是非常有作用。 ","date":"2020-05-20 11:14:00","objectID":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/:0:1","tags":["容器","微服务"],"title":"Docker网络详解","uri":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/"},{"categories":["容器-微服务"],"content":"2.host 网络 这种网络配置是和Docker host共享它的网络栈，容器的网络配置与host完全一样，可以看下。 可以看下，是通过–network=host 来配置网络模式是host模式。可以看到，它的网络配置主机的网络配置完全一致。 使用场景是什么呢，就是如果容器对网络传输效率有较高的要求，可以选择这种模式，但是缺点也很明显，就是不太灵活，要考虑端口冲突问题。 ","date":"2020-05-20 11:14:00","objectID":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/:0:2","tags":["容器","微服务"],"title":"Docker网络详解","uri":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/"},{"categories":["容器-微服务"],"content":"3. bridge 网络 这种是用的最多的，默认情况下就是创建的bridge网络模式。 可以看到，有两个桥接网络，第一个是我手动创建的一个桥接，第二个是Docker host默认的一个桥接网络，当每用默认网络模式创建一个docker实例时，就会在默认的Docker桥接下增加一个interface。 可以创建一个桥接模式的docker试试看。 我创建了一个Docker实例，然后在docker0的桥接下多了一个interface。 可以看下这个网络配置， 网络名称是if48. 这个是bridge的网络参数。同时Docker Host的ip是172.17/0.1，整个的网络模型如下所示： 这个就是一个bridge模式。 ","date":"2020-05-20 11:14:00","objectID":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/:0:3","tags":["容器","微服务"],"title":"Docker网络详解","uri":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/"},{"categories":["容器-微服务"],"content":"4. User-defined 网络 这个是指根据自己的需要配置docker的网络，这种就比较灵活了，docker提供了三种user-defined的网络驱动：bridge, overlay 和 macvlan。 以bridge网络为例，如果两个docker是在不同的bridge下，互相通信是肯定不行的；如果它们是属于同一个网桥下，这个时候肯定是可以的，如下图。 怎么样可以让httpd和busybox的网桥通信呢，可以在httpd容器下添加一块net_my2的网卡，通过下面的方法进行连接。 之后网络模型就如下所示了： ","date":"2020-05-20 11:14:00","objectID":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/:0:4","tags":["容器","微服务"],"title":"Docker网络详解","uri":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/"},{"categories":["容器-微服务"],"content":"5. 容器间的通信 我们知道，如果两个容器是在一个bridge下，可以互相通信，如果不在一个bridge下，可以通过docker network connect将现有容器加入到指定网格中。但是有个问题啊，我们知道容器的IP是动态变化的，不能光靠ip的方式来访问容器，可以通过网络名称方式来访问。但是这种方式只能在user-defined网络中使用，不能在默认的bridge中。 ","date":"2020-05-20 11:14:00","objectID":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/:0:5","tags":["容器","微服务"],"title":"Docker网络详解","uri":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/"},{"categories":["容器-微服务"],"content":"6. joined 容器 Joined容器是另外一种实现容器通信的方式。它是使两个或多个容器共享一个网络栈，共享网卡和配置信息。 我用一个实例来演示下。 我先创建一个httpd的容器。 然后再创建一个busybox的容器加入到web1这个容器里。 同时看下它的网络配置。我比较下web1的网络配置。 它们的网络是完全一样的。 现在在busybox的容器里直接通过127.0.0.1来访问web容器，发现是可以直接访问的，也证明了这两个容器是网络互通。 ","date":"2020-05-20 11:14:00","objectID":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/:0:6","tags":["容器","微服务"],"title":"Docker网络详解","uri":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/"},{"categories":["容器-微服务"],"content":"7. 容器访问外部世界 我们知道，我们运行的容器是可以直接访问外网的。 看这个，可以直接访问的。这个是怎么实现的呢。 它是通过nat转换，将内部的网络地址转换为host的网络地址发送出去。整个过程如下图所示： 这个图非常清晰的说明了整个过程。 ","date":"2020-05-20 11:14:00","objectID":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/:0:7","tags":["容器","微服务"],"title":"Docker网络详解","uri":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/"},{"categories":["容器-微服务"],"content":"8. 外部网络访问Docker容器 外部网络访问Docker容器是通过端口映射的方式实现的，就是启动容器后，将端口映射到host的某一个端口。 这个就是将docker的80端口映射到了host的32768端口上，可以通过host的ip加32768端口来访问容器。 也可以在创建容器时，静态的指定端口。 整个过程可以用下图来表示。 整个过程是从左到右，通过docker-proxy转发给容器172.17.0.2. ","date":"2020-05-20 11:14:00","objectID":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/:0:8","tags":["容器","微服务"],"title":"Docker网络详解","uri":"https://yeliansong.github.io/2020-6-14-docker-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/"},{"categories":["CKA考试"],"content":"CKA考试","date":"2020-05-04 09:31:00","objectID":"https://yeliansong.github.io/2020-05-11-k8s-command/","tags":["CKA考试","微服务"],"title":"K8S 常用命令","uri":"https://yeliansong.github.io/2020-05-11-k8s-command/"},{"categories":["CKA考试"],"content":" #查看所有namespace的pods运行情况 kubectl get pods --all-namespaces #查看具体pods，记得后边跟namespace名字哦 kubectl get pods kubernetes-dashboard-76479d66bb-nj8wr --namespace=kube-system # 查看pods具体信息 kubectl get pods -o wide kubernetes-dashboard-76479d66bb-nj8wr --namespace=kube-system # 查看集群健康状态 kubectl get cs # 获取所有deployment kubectl get deployment --all-namespaces # 列出该 namespace 中的所有 pod 包括未初始化的 kubectl get pods --include-uninitialized # 查看deployment() kubectl get deployment nginx-app # 查看rc和servers kubectl get rc,services # 查看pods结构信息（重点，通过这个看日志分析错误） # 对控制器和服务，node同样有效 kubectl describe pods xxxxpodsname --namespace=xxxnamespace # 其他控制器类似吧，就是kubectl get 控制器 控制器具体名称 # 查看pod日志 kubectl logs $POD_NAME # 查看pod变量 kubectl exec my-nginx-5j8ok -- printenv | grep SERVICE # 集群 kubectl get cs # 集群健康情况 kubectl cluster-info # 集群核心组件运行情况 kubectl get namespaces # 表空间名 kubectl version # 版本 kubectl api-versions # API kubectl get events # 查看事件 kubectl get nodes //获取全部节点 kubectl delete node k8s2 //删除节点 kubectl rollout status deploy nginx-test # 创建 kubectl create -f ./nginx.yaml # 创建资源 kubectl create -f . # 创建当前目录下的所有yaml资源 kubectl create -f ./nginx1.yaml -f ./mysql2.yaml # 使用多个文件创建资源 kubectl create -f ./dir # 使用目录下的所有清单文件来创建资源 kubectl create -f https://git.io/vPieo # 使用 url 来创建资源 kubectl run -i --tty busybox --image=busybox ----创建带有终端的pod kubectl run nginx --image=nginx # 启动一个 nginx 实例 kubectl run mybusybox --image=busybox --replicas=5 ----启动多个pod kubectl explain pods,svc # 获取 pod 和 svc 的文档 # 更新 kubectl rolling-update python-v1 -f python-v2.json # 滚动更新 pod frontend-v1 kubectl rolling-update python-v1 python-v2 --image=image:v2 # 更新资源名称并更新镜像 kubectl rolling-update python --image=image:v2 # 更新 frontend pod 中的镜像 kubectl rolling-update python-v1 python-v2 --rollback # 退出已存在的进行中的滚动更新 cat pod.json | kubectl replace -f - # 基于 stdin 输入的 JSON 替换 pod 强制替换，删除后重新创建资源。会导致服务中断。 kubectl replace --force -f ./pod.json 为 nginx RC 创建服务，启用本地 80 端口连接到容器上的 8000 端口 kubectl expose rc nginx --port=80 --target-port=8000 更新单容器 pod 的镜像版本（tag）到 v4 kubectl get pod nginx-pod -o yaml | sed 's/\\(image: myimage\\):.*$/\\1:v4/' | kubectl replace -f - kubectl label pods nginx-pod new-label=awesome # 添加标签 kubectl annotate pods nginx-pod icon-url=http://goo.gl/XXBTWq # 添加注解 kubectl autoscale deployment foo --min=2 --max=10 # 自动扩展 deployment “foo” # 编辑资源 kubectl edit svc/docker-registry # 编辑名为 docker-registry 的 service KUBE_EDITOR=\"nano\" kubectl edit svc/docker-registry # 使用其它编辑器 # 动态伸缩pod kubectl scale --replicas=3 rs/foo # 将foo副本集变成3个 kubectl scale --replicas=3 -f foo.yaml # 缩放“foo”中指定的资源。 kubectl scale --current-replicas=2 --replicas=3 deployment/mysql # 将deployment/mysql从2个变成3个 kubectl scale --replicas=5 rc/foo rc/bar rc/baz # 变更多个控制器的数量 kubectl rollout status deploy deployment/mysql # 查看变更进度 # 删除 kubectl delete -f ./pod.json # 删除 pod.json 文件中定义的类型和名称的 pod kubectl delete pod,service baz foo # 删除名为“baz”的 pod 和名为“foo”的 service kubectl delete pods,services -l name=myLabel # 删除具有 name=myLabel 标签的 pod 和 serivce kubectl delete pods,services -l name=myLabel --include-uninitialized # 删除具有 name=myLabel 标签的 pod 和 service，包括尚未初始化的 kubectl -n my-ns delete po,svc --all # 删除 my-ns namespace下的所有 pod 和 serivce，包括尚未初始化的 kubectl delete pods prometheus-7fcfcb9f89-qkkf7 --grace-period=0 --force 强制删除 # 交互 kubectl logs nginx-pod # dump 输出 pod 的日志（stdout） kubectl logs nginx-pod -c my-container # dump 输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用） kubectl logs -f nginx-pod # 流式输出 pod 的日志（stdout） kubectl logs -f nginx-pod -c my-container # 流式输出 pod 中容器的日志（stdout，pod 中有多个容器的情况下使用） kubectl run -i --tty busybox --image=busybox -- sh # 交互式 shell 的方式运行 pod kubectl attach nginx-pod -i # 连接到运行中的容器 kubectl port-forward nginx-pod 5000:6000 # 转发 pod 中的 6000 端口到本地的 5000 端口 kubectl exec nginx-pod -- ls / # 在已存在的容器中执行命令（只有一个容器的情况下） kubectl exec nginx-pod -c my-container -- ls / # 在已存在的容器中执行命令（pod 中有多个容器的情况下） kubectl top pod POD_NAME --containers # 显示指定 pod和容器的指标度量 # 调度配置 $ kubectl cordon k8s-node # 标记 my-node 不可调度 $ kubectl drain k8s-node # 清空 ","date":"2020-05-04 09:31:00","objectID":"https://yeliansong.github.io/2020-05-11-k8s-command/:0:0","tags":["CKA考试","微服务"],"title":"K8S 常用命令","uri":"https://yeliansong.github.io/2020-05-11-k8s-command/"},{"categories":["CKA考试"],"content":"CKA考试","date":"2020-05-02 11:00:00","objectID":"https://yeliansong.github.io/2019-10-19-cka-%E8%80%83%E5%89%8D%E8%B5%84%E6%96%99/","tags":["CKA考试","微服务"],"title":"CKA 考试资料","uri":"https://yeliansong.github.io/2019-10-19-cka-%E8%80%83%E5%89%8D%E8%B5%84%E6%96%99/"},{"categories":["CKA考试"],"content":"1. 考点分布 CKA: Certified Kubernetes Administrator. CNCF: Cloud Native Computing Foundation. 知识点划分： 5%: scheduling 5%: Logging/Monitoring 8%: Application Lifecycle Management 11%: Cluster 12%: Security 7%: Storage 10%: Troubleshooting 19%:Core Concepts 11%:Networking s12%:Installation, Configuration \u0026 Validation ","date":"2020-05-02 11:00:00","objectID":"https://yeliansong.github.io/2019-10-19-cka-%E8%80%83%E5%89%8D%E8%B5%84%E6%96%99/:0:1","tags":["CKA考试","微服务"],"title":"CKA 考试资料","uri":"https://yeliansong.github.io/2019-10-19-cka-%E8%80%83%E5%89%8D%E8%B5%84%E6%96%99/"},{"categories":["CKA考试"],"content":"K8S学习的读书笔记","date":"2020-05-01 19:00:00","objectID":"https://yeliansong.github.io/2020-3-14-kubeadm-concept-and-practice/","tags":["CKA考试","微服务"],"title":"kubeadm 概念与实践","uri":"https://yeliansong.github.io/2020-3-14-kubeadm-concept-and-practice/"},{"categories":["CKA考试"],"content":"1.kubeadm知识图谱 Kubeadm是一个快速实现k8s环境的工具。 另外，您不需要关心配置环境，只需知道如何引导它即可。 掌握使用 kubeadm 的基本命令。 ","date":"2020-05-01 19:00:00","objectID":"https://yeliansong.github.io/2020-3-14-kubeadm-concept-and-practice/:0:1","tags":["CKA考试","微服务"],"title":"kubeadm 概念与实践","uri":"https://yeliansong.github.io/2020-3-14-kubeadm-concept-and-practice/"},{"categories":["CKA考试"],"content":"2.Kubeadm实践 2.1 练习环境 谷歌云实例 Linux系统。 2.2 环境配置 安装容器（Docker） # 安装 Docker CE ## 设置仓库 ### 安装软件包以允许 apt 通过 HTTPS 使用存储库 apt-get update \u0026\u0026 apt-get install \\ apt-transport-https ca-certificates curl software-properties-common ### 新增 Docker 的 官方 GPG 秘钥 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - ### 添加 Docker apt 仓库 add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" ## 安装 Docker CE apt-get update \u0026\u0026 apt-get install docker-ce=18.06.2~ce~3-0~ubuntu # 设置 daemon cat \u003e /etc/docker/daemon.json \u003c\u003cEOF { \"exec-opts\": [\"native.cgroupdriver=systemd\"], \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\" }, \"storage-driver\": \"overlay2\" } EOF mkdir -p /etc/systemd/system/docker.service.d # 重启 docker. systemctl daemon-reload systemctl restart docker 安装 kubeadm、kubectl 和 kubelet apt-get update \u0026\u0026 apt-get install -y apt-transport-https curl curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - cat \u003c\u003cEOF \u003e /etc/apt/sources.list.d/kubernetes.list deb https://apt.kubernetes.io/ kubernetes-xenial main EOF apt-get update apt-get install -y kubelet kubeadm kubectl apt-mark hold kubelet kubeadm kubectl 2.3 kubeadm 实践 背景：使用kubeadm创建k8s主节点，然后将其他节点循环到该主节点。 初始化主节点。 kubeadm init --pod-network-cidr=10.244.0.0/16 --ignore-preflight-errors=all pod-network-cidr，表示识别pod ip范围，我们也使用flannel网络设计方案。 忽略，表示忽略启动时的错误。 因为在启动kubeadm的时候，可能会碰到硬件不舒服。 启动成功后，会生成kubeadm token，该token可以用来加入其他节点。 您可以使用以下命令来查看令牌。 kubeadm token list 配置 kubectl。 众所周知，kubectl是控制kubernetes集群的命令工具。 当我们切换到master节点时，我们需要配置kubectl。 mkdir -p $HOME/.kube cp -i /etc/kubernetes/admin.conf $HOME/.kube/config chown $(id -u):$(id -g) $HOME/.kube/config echo export KUBECONFIG=~/.kube/config\u003e\u003e ~/.bashrc source ~/.bashrc 安装 Pod 网络插件。 安装 Pod 网络后，Pod 之间可以相互通信。 我们也使用flannel网络模式。 kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/2140ac876ef134e0ed5af15c65e414cf26827915/Documentation/kube-flannel.yml 将其他节点加入集群。 sudo kubeadm join 10.128.0.2:6443 --token 5dhzcw.h7aih16mg982ms2o --discovery-token-ca-cert-hash sha256:e9e6843a6ae6fc5fb8acb9f116bc58d1c1e0f30d1da9bfe3bf151319c3788d57 --ignore-preflight-errors=all 清理环境。 部署后，您可以清理环境。 sudo kubeadm reset ","date":"2020-05-01 19:00:00","objectID":"https://yeliansong.github.io/2020-3-14-kubeadm-concept-and-practice/:0:2","tags":["CKA考试","微服务"],"title":"kubeadm 概念与实践","uri":"https://yeliansong.github.io/2020-3-14-kubeadm-concept-and-practice/"},{"categories":["CKA考试"],"content":"3.附加 事实上，当你按照步骤去做的时候，会出现很多问题。 未解决的问题： 执行kubeadm join命令后，终端显示添加成功，但实际上节点列表中并不存在新节点。 解决方案：我误解了kubeadm的概念，所以碰到了这个问题。 实际上，kubeadm 的目的是创建实现 k8s 环境，因此当您执行 kubeadm init 命令时，它会创建 kubenetes 主节点。 然后就可以将其他节点安排到这个主节点上。 所以我的解决方案是这样的。 首先，创建一个新实例，然后在该实例中配置容器、kubectl、kubelet 和 kubeadm 工具。 之后，执行此命令。 kubeadm join --token 5dhzcw.h7aih16mg982ms2o 10.128.0.2:6443 --discovery-token-ca-cert-hash sha256:e9e6843a6ae6fc5fb8acb9f116bc58d1c1e0f30d1da9bfe3bf151319c3788d57 --ignore-preflight-errors=all 当然，您必须是 root 角色。 结果如下。 在节点机器中，当您执行命令“kubectl version”或“kubectl getnodes”时，会遇到此问题。 您可以下载主节点“/etc/kubernetes/admin.conf”，然后将此文件复制到节点机器路径“/etc/kubernetes/”。 然后按照前面的步骤配置 kubectl。 ","date":"2020-05-01 19:00:00","objectID":"https://yeliansong.github.io/2020-3-14-kubeadm-concept-and-practice/:0:3","tags":["CKA考试","微服务"],"title":"kubeadm 概念与实践","uri":"https://yeliansong.github.io/2020-3-14-kubeadm-concept-and-practice/"},{"categories":["CKA考试"],"content":"4.参考链接 如何安装泊坞窗。 https://kubernetes.io/docs/setup/生产环境/container-runtimes/#docker 如何安装 kubectl、kubeadm、kubelet。 [https://kubernetes.io/docs/setup/product-environment/tools/kubeadm/install-kubeadm/#installing-kubeadm-kubelet-and-kubectl](https://kubernetes.io/docs/setup/ 生产环境/工具/kubeadm/install-kubeadm/#installing-kubeadm-kubelet-and-kubectl) 练习指导。 [https://kubernetes.io/docs/setup/生产环境/tools/kubeadm/create-cluster-kubeadm/](https://kubernetes.io/docs/setup/生产环境/tools/kubeadm/ 创建集群-kubeadm/) ","date":"2020-05-01 19:00:00","objectID":"https://yeliansong.github.io/2020-3-14-kubeadm-concept-and-practice/:0:4","tags":["CKA考试","微服务"],"title":"kubeadm 概念与实践","uri":"https://yeliansong.github.io/2020-3-14-kubeadm-concept-and-practice/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"第一部分： 这部分内容包括云历史、容器技术、k8s等基础知识。 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:0:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"1. 云技术 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:1:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"1.1 云计算的历史 https://skyao.io/learning-cloudnative/introduction/history.html IaaS：基础设施即服务 PaaS：平台即服务 SaaS：软件即服务 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:1:1","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"1.2 云原生 https://skyao.io/learning-cloudnative/introduction/background.html ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:1:2","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"1.3 DevOps 和优势 https://www.qikegu.com/docs/4262 https://skyao.io/learning-cloudnative/devops/ ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:1:3","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"2. 容器技术 2.1 虚拟化技术 虚拟化是指创建某种事物的虚拟版本的行为，包括虚拟计算机硬件平台、存储设备和计算机网络资源等。它让您使用传统上与硬件绑定的资源创建有用的IT服务，允许您使用物理资源 通过将其功能分配给许多用户或环境来充分发挥机器的能力。 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:2:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"2.2 虚拟机与容器 VM：虚拟机 容器 容器与虚拟机的比较 使用Container的优点： 容器更加轻量级，它类似于在主机操作系统中运行的单个隔离进程。 容器启动比虚拟机更快。 容器更适合微服务。 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:2:1","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"2.3 码头工人 Docker是一家位于旧金山的基于容器技术的初创公司。 这是容器技术的最佳实践。 然后它就成为与其他企业竞争的标准。 Docker代表容器技术。 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:2:2","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"3. 微服务 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:3:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"3.1 单一应用程序 单体应用程序是传统的部署设计模型。 参考上图，进程数是相互依赖的。 缺点也是显而易见的，整个系统的部署比较繁琐。 升级单个应用程序是有风险的。 因为它与其他部分相连。 另外，开发人员和运维工作很难分开，开发人员有时需要关心管理的问题，系统运维人员也需要定位是否是软件问题。 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:3:1","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"3.2 微服务 上图非常形象的表达了微服务的范围。 从单体应用到微服务应用。 微服务是一种软件开发技术，它将应用程序安排为松散耦合服务的集合。 在微服务架构中，服务是细粒度的，协议是轻量级的。 更容易构建和维护应用程序。 使用技术的灵活性和可扩展性 与 Jenkins 等持续集成工具轻松集成和自动部署。 还可以实现持续交付。 ——提高开发效率。 降低不同团队之间的沟通成本。 不同服务的代码可以用不同的语言编写。 打破不同语言和技术的障碍。 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:3:2","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"4. 库伯内特斯 https://www.infoq.cn/article/U2a_7ekuvhmb7dSNp27V 第二部分： 这部分是k8s的细节。 会介绍k8s的要点和一些做法。 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:4:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"1. K8S 开胃菜 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:5:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"1.1 了解K8S集群架构 k8s部署处理的实践 链接：[https://yeliansong.github.io/2020/03/22/Understand-The-K8S-Architecture/](https://yeliansong.github.io/2020/03/22/Understand-The-K8S -建筑学/） ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:5:1","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"1.2 K8S对象的概念 Pod：是k8s平台上的原子单元。 一个 Pod 包含不同的应用程序容器，这些容器耦合得相对紧密。 Node：Pod 总是运行在 Node 上，Node 是 k8s 中的工作机器，可以是虚拟机也可以是物理机，具体取决于集群。 每个Node都由Master管理。 集群：一组Node机器，一个集群包含一个worker Node和一个master Node。 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:5:2","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"2. 使用 Kubeadm 创建 K8S 环境 我们有两种创建 K8S 环境的方法。 1）利用云，包括GCP、AWS或华为云。 他们已经安装了 K8S 插件。 我们可以轻松部署我们的应用程序。 2）使用k8s工具在物理机中创建k8s环境。 链接：[https://yeliansong.github.io/2020/03/14/kubeadm-concept-and-practice/](https://yeliansong.github.io/2020/03/14/kubeadm-concept-and -实践/） ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:6:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"3. K8S 对象的部署方式 通常有两种方法来部署我们的应用程序。 命令和 Yaml 文件。 命令。 YAML 文件 Yaml 是一种配置文件。 格式为键值对。 我们还可以使用 YAML 文件部署我们的应用程序。 apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deploymnet spec: replicas: 3 selector: matchLabels: app: web_server template: metadata: labels: app: web_server spec: containers: - name: nginx image: nginx:1.7.9 链接：https://yeliansong.github.io/2020/04/08/How-to-write-the-YAML/（如何编写YAML） ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:7:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"4. 工作负载 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:8:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"4.1 Pod 链接：https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-overview/ ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:8:1","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"4.2 控制器 链接：https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicaset/ 部署 规则和格式。 （在 GCP 中显示） Deployment 和 Pod 之间的关系。 （在 GCP 中显示） DemonSet ReplicationController ReplicaSet ReplicaSet 可确保在任何给定时间运行指定数量的 pod 副本。 但部署是一个高级概念，它管理 Pod 的 ReplicaSet 以及许多其他有用的功能。 推荐使用 Deployments 而不是直接使用 RS。 状态集 工作 链接：https://yeliansong.github.io/2020/04/25/Deployment/ PDF：[https://github.com/yeliansong/yeliansong.github.io/blob/master/_posts/Deployment.pdf](https://github.com/yeliansong/yeliansong.github.io/blob/master/ _posts/部署.pdf） ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:8:2","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"5.K8S网络 链接：https://yeliansong.github.io/2020/04/23/K8S-Network/ PDF：[https://github.com/yeliansong/yeliansong.github.io/blob/master/_posts/K8S%20Network.pdf](https://github.com/yeliansong/yeliansong.github.io/blob/ master/_posts/K8S Network.pdf) ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:9:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"6. 部署策略 链接：https://yeliansong.github.io/2020/04/22/K8S-Deployment-Strategies/ PDF：[https://github.com/yeliansong/yeliansong.github.io/blob/master/_posts/K8S%20Deployment%20Strategies.pdf](https://github.com/yeliansong/yeliansong.github.io/ blob/master/_posts/K8S 部署策略.pdf) ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:10:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"7. 健康检查 链接：[https://yeliansong.github.io/2020/04/11/Health-Check/](https://yeliansong.github.io/2020/04/11/Health-查看/） PDF：[https://github.com/yeliansong/yeliansong.github.io/blob/master/_posts/Health%20Check.pdf](https://github.com/yeliansong/yeliansong.github.io/blob/ master/_posts/健康检查.pdf) ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:11:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"8. volume 链接：https://yeliansong.github.io/2020/04/14/Volume/ PDF：[https://github.com/yeliansong/yeliansong.github.io/blob/master/_posts/Volume.pdf](https://github.com/yeliansong/yeliansong.github.io/blob/master/ _posts/Volume.pdf) 第 三部分 ","date":"2020-04-26 19:00:00","objectID":"https://yeliansong.github.io/2020-4-24-sharing/:12:0","tags":["K8S","微服务"],"title":"云技术、容器及K8S 分享","uri":"https://yeliansong.github.io/2020-4-24-sharing/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2020-04-01 10:11:51","objectID":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/","tags":["K8S","微服务"],"title":"Secret And ConfigMap","uri":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/"},{"categories":["K8S-学习笔记"],"content":"1. 背景 到目前为止，也许您不必将任何类型的配置数据传递给应用程序。 因为几乎所有应用程序都需要配置，不应将其融入到构建的应用程序本身中。 本文介绍了将配置数据传递到应用程序的两种方法。 ","date":"2020-04-01 10:11:51","objectID":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/:0:1","tags":["K8S","微服务"],"title":"Secret And ConfigMap","uri":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/"},{"categories":["K8S-学习笔记"],"content":"2.密钥 密钥是因为您传递给容器的信息是敏感的。 K8s 提供了一个单独的对象，称为 Secret。 有 4 种创建 Secret 的方法。 通过 –from-literal kubectl create secret generic mysecret --from-literal=username=admin --from-literal=password=123456 通过–from-file，每个文件包含一项。 echo -n admin \u003e ./username echo -n 123456 \u003e ./password kubectl create secret generic mysecret1 --from-file=./username --from-file=./password 通过–from-env-file。 在 env.txt 中，每一行键值都匹配一项。 cat \u003c\u003c EOF \u003e env.txt username=admin password=123456 EOF kubectl create secret generic mysecret --from-env-file=env.txt 通过 YAML 文件。 apiVersion: v1 kind: Secret metadata: name: mysecret data: username: YWRtaW4= password: NTY3ODk= 用户名和密码是敏感信息，因此会被加密。 然后可以使用：“kubectl apply -f my Secret.yaml”来创建秘密。 创建秘密后，可以使用命令显示秘密。 像这样。 您也可以使用describe命令来显示详细信息。 在此图中，您可以看到密码和用户名已加密。 ","date":"2020-04-01 10:11:51","objectID":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/:0:2","tags":["K8S","微服务"],"title":"Secret And ConfigMap","uri":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/"},{"categories":["K8S-学习笔记"],"content":"3.如何在Pod中使用secret 我们知道，Secret是k8s中分离的对象，所以pod会通过卷来使用secret。 如何使用，如下。 创建 pod，在 pod 中定义卷，也来自秘密。 （体积） apiVersion: v1 kind: Pod metadata: name: mypod spec: containers: - name: mypod image: busybox args: - /bin/sh - -c - sleep 10; touch /tmp/healthy; sleep 30000 volumeMounts: - name: foo mountPath: \"/etc/foo\" readOnly: true volumes: - name: foo secret: secretName: mysecret 从Yaml文件中我们可以看到，将秘钥值挂载到路径：/etc/foo. 然后我们就可以查看秘密了。 也可以将数据保存到组路径中。 这样，我们就可以保存秘密加密。 创建 Pod，在 Pod 中定义 env 变量。 （环境） apiVersion: v1 kind: Pod metadata: name: mypod-env spec: containers: - name: mypod-env image: busybox args: - /bin/sh - -c - sleep 10; touch /tmp/healthy; sleep 30000 env: - name: SECRET_USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: SECRET_PASSWORD valueFrom: secretKeyRef: name: mysecret key: password 在 pod 中，定义键和值。 然后就可以通过环境变量获取值了。 ","date":"2020-04-01 10:11:51","objectID":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/:0:3","tags":["K8S","微服务"],"title":"Secret And ConfigMap","uri":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/"},{"categories":["K8S-学习笔记"],"content":"4. 配置映射 k8s 允许将配置选项分离到一个名为 ConfigMap 的单独对象中。 这与秘密不同。 它习惯于不敏感的数据。 让我们展示一下。 和secret一样，有4种创建ConfigMap的方法。 通过 –from-literal kubectl create configmap myconfigmap --from-literal=config1=xxx --from-literal=config2=yyy 通过–from-file echo -n xxx \u003e ./config1 echo -n yyy \u003e ./config2 kubectl create configmap myconfigmap2 --from-file=./config1 --from-file=./config2 通过 –from-evn-file cat \u003c\u003c EOF \u003e env.txt config1=xxx config2=yyy EOF kubectl create configmap myconfigmap3 --from-env-file=env.txt 通过YAML文件 apiVersion: v1 kind: ConfigMap metadata: name: myconfigmap data: config1: xxx config2: yyy 这和秘密是一样的。 由此，可以创建单独的config对象，然后可以在Pod中使用。 ","date":"2020-04-01 10:11:51","objectID":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/:0:4","tags":["K8S","微服务"],"title":"Secret And ConfigMap","uri":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/"},{"categories":["K8S-学习笔记"],"content":"5.如何在Pod中使用configmap 这和秘密是一样的。 configmap就像一个单独的对象，然后Pod可以使用该对象并获取键值。 下面是关于configmap的一种实践。 创建配置映射。 apiVersion: v1 kind: ConfigMap metadata: name: myconfigmap5 data: logging.conf: | class: logging.handlers.RotatingFileHandler formatter: precise level: INFO filename: %hostname-%timestamp.log 使用配置映射创建 Pod。 apiVersion: v1 kind: Pod metadata: name: mypodconfig spec: containers: - name: mypodconfig image: busybox args: - /bin/sh - -c - sleep 10; touch /tmp/healthy; sleep 30000 volumeMounts: - name: foo mountPath: \"/etc/foo\" volumes: - name: foo configMap: name: myconfigmap5 items: - key: logging.conf path: myapp/logging.conf 在此 Pod 中，定义安装路径。 然后执行以下命令。 ","date":"2020-04-01 10:11:51","objectID":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/:0:5","tags":["K8S","微服务"],"title":"Secret And ConfigMap","uri":"https://yeliansong.github.io/2020-05-03-secret-and-configmap/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2020-03-27 10:11:51","objectID":"https://yeliansong.github.io/2020-4-22-k8s-deployment-strategies/","tags":["K8S","微服务"],"title":"K8S部署策略","uri":"https://yeliansong.github.io/2020-4-22-k8s-deployment-strategies/"},{"categories":["K8S-学习笔记"],"content":"1. 背景 我们总是将最终版本的应用程序部署到生产环境。 有多种方法可以保证发布生产的稳定和安全。 以下部分是 k8s 部署策略。 ","date":"2020-03-27 10:11:51","objectID":"https://yeliansong.github.io/2020-4-22-k8s-deployment-strategies/:0:1","tags":["K8S","微服务"],"title":"K8S部署策略","uri":"https://yeliansong.github.io/2020-4-22-k8s-deployment-strategies/"},{"categories":["K8S-学习笔记"],"content":"2. 策略 有 4 种方法可以进行生产发布。 1）滚动更新。 2）重新创建。 3) 蓝色/绿色。 4）金丝雀。 以下是详细信息。 重新创建更新 这是一种非常笨拙的更新方式。 销毁V1应用程序然后创建V2应用程序。 在一段时间内会遇到服务中断问题。 滚动更新。 这是最常用的。 使用 RC 执行自动滚动更新 apiVersion: v1 kind: ReplicationController metadata: name: kubia-v1 spec: replicas: 3 template: metadata: name: kubia labels: app: kubia spec: containers: - image: luksa/kubia:v1 name: nodejs --- apiVersion: v1 kind: Service metadata: name: kubia spec: type: NodePort selector: app: kubia ports: - port: 80 targetPort: 8080 nodePort: 30007 要运行此应用程序，将创建 ReplicationController 和 NodePort 服务，以便能够从外部访问该应用程序。 然后再打开另一个终端来监控服务。 然后使用 kubectl 执行滚动更新，将创建应用程序的版本 2。 执行以下命令： kubectl 滚动更新 kubia-v1 kubia-v2 --image=luksa/kubia:v2 使用部署以声明方式更新应用程序 部署是一种高级资源，用于部署应用程序并以声明方式更新它们，而不是通过 RC 或 RS 来完成，这两者都被认为是较低级别的概念。 apiVersion: apps/v1 kind: Deployment metadata: name: kubia-v1 spec: replicas: 3 selector: matchLabels: app: kubia template: metadata: name: kubia labels: app: kubia spec: containers: - image: luksa/kubia:v1 name: nodejs --- apiVersion: v1 kind: Service metadata: name: kubia spec: type: NodePort selector: app: kubia ports: - port: 80 同样要运行此应用程序，完成后，将 v1 部署容器更改为 v2，然后使用新版本进行部署。 kubectl apply -f kubia-deploy-v2.yaml 之后，您可以注意到将保留V1 RS。 所以版本从V2回滚到V1是非常容易的。 使用此命令回滚部署。 kubectl 推出撤消部署 kubia kubectl 推出历史部署 kubia kubectl 推出撤消部署 kubia --to-revision=1 蓝绿 实际上这个部署需要V1和V2应用程序已经存在。 客户端通过标签连接Deployment。 金丝雀部署 ","date":"2020-03-27 10:11:51","objectID":"https://yeliansong.github.io/2020-4-22-k8s-deployment-strategies/:0:2","tags":["K8S","微服务"],"title":"K8S部署策略","uri":"https://yeliansong.github.io/2020-4-22-k8s-deployment-strategies/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2020-03-13 16:11:51","objectID":"https://yeliansong.github.io/2020-4-23-k8s-network/","tags":["K8S","微服务"],"title":"K8S网络","uri":"https://yeliansong.github.io/2020-4-23-k8s-network/"},{"categories":["K8S-学习笔记"],"content":"K8S网络分为3级。 从内到外，有3种： 1）容器网络。 2) 集群内网络。 3) 外部集群网络。 以下是详细信息， ","date":"2020-03-13 16:11:51","objectID":"https://yeliansong.github.io/2020-4-23-k8s-network/:0:0","tags":["K8S","微服务"],"title":"K8S网络","uri":"https://yeliansong.github.io/2020-4-23-k8s-network/"},{"categories":["K8S-学习笔记"],"content":"1.容器网络 Docker 网络仅限于主机本身。 默认情况下，它创建一个名为 docker0 的虚拟网桥，并为每个容器分配一个附加到网桥 docker0 的虚拟乙烷。 因此，在 Docker 中，如果两个容器驻留在同一主机上，则它们可以相互通信。 ","date":"2020-03-13 16:11:51","objectID":"https://yeliansong.github.io/2020-4-23-k8s-network/:0:1","tags":["K8S","微服务"],"title":"K8S网络","uri":"https://yeliansong.github.io/2020-4-23-k8s-network/"},{"categories":["K8S-学习笔记"],"content":"2. 集群内网络 这意味着 Pod 之间进行通信。 集群中所有Pod共享同一个网段。 所以 Pod 之间可以直接通信。 也可以将Pod暴露给一个服务，然后集群中的其他应用程序就可以访问该Pod服务。 像这样， ","date":"2020-03-13 16:11:51","objectID":"https://yeliansong.github.io/2020-4-23-k8s-network/:0:2","tags":["K8S","微服务"],"title":"K8S网络","uri":"https://yeliansong.github.io/2020-4-23-k8s-network/"},{"categories":["K8S-学习笔记"],"content":"3.外部集群网络 如何从外部访问k8s集群网络？ 构建网络模型有3种方法。 3.1。 负载均衡器 LoadBalacer 服务是向互联网公开服务的标准方法。 但只有在AWS或Google Cloud上才能使用此功能。 在 GKE 上，这将启动一个网络负载均衡器，该负载均衡器将为您提供一个 IP 地址，将所有流量转发到您的服务。 如果你想直接公开一个服务，这是默认方法。 您指定的端口上的所有流量都将转发到该服务。没有过滤、没有路由等。这意味着您可以向其发送几乎任何类型的流量，例如 HTTP、TCP、UDP。 Websocket、gRPC 或其他。 最大的缺点是，您使用 LoadBalancer 公开的每个服务都将获得自己的 IP 地址，并且您必须为每个公开的服务支付 LoadBalancer 费用，这可能会很昂贵。 3.2。 节点端口 NodePort 服务是将外部流量直接发送到您的服务的最原始方式。 NodePort，顾名思义，在所有Node上打开一个特定的端口，任何发送到该端口的流量都会转发到服务。 3.3。 入口 与上述所有示例不同，Ingress 实际上不是一种服务。 相反，它位于多个服务的前面，并充当集群的“智能路由器”或入口点。您可以使用 Ingress 执行许多不同的操作，并且有许多类型的 Ingress 控制器具有不同的功能。 apiVersion: extensions/v1beta1 kind: Ingress metadata: name: my-ingress spec: backend: serviceName: other servicePort: 8080 rules: - host: foo.mydomain.com http: paths: - backend: serviceName: foo servicePort: 8080 - host: mydomain.com http: paths: - path: /bar/* backend: serviceName: bar servicePort: 8080 ","date":"2020-03-13 16:11:51","objectID":"https://yeliansong.github.io/2020-4-23-k8s-network/:0:3","tags":["K8S","微服务"],"title":"K8S网络","uri":"https://yeliansong.github.io/2020-4-23-k8s-network/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2020-02-28 09:11:51","objectID":"https://yeliansong.github.io/2020-4-11-health-check/","tags":["K8S","微服务"],"title":"健康检查","uri":"https://yeliansong.github.io/2020-4-11-health-check/"},{"categories":["K8S-学习笔记"],"content":"1.关于K8S健康检查 健康检查是k8s编排的重要功能。 K8s 可以监控这些容器，并在发生故障时自动重新启动它们。 如果容器的主进程崩溃，k8s将重新启动容器。 另外，如果你的应用程序有bug导致它偶尔崩溃，k8s会自动重新启动它。健康检查有两种方式。 活跃度和准备度。 有什么不同？ 以及如何使用这些？ 活性探针 k8s 可以通过活性探针检查容器是否仍然存活。 您可以在 pod 规范中为每个容器指定一个活性探针。 k8s会定期执行探测，如果探测失败则重启容器。 活性健康检查配置文件。 apiVersion: v1 kind: Pod metadata: labels: test: liveness name: liveness spec: restartPolicy: OnFailure containers: - name: liveness image: busybox args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 60 livenessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 10 periodSeconds: 5 从这个配置文件中，我们定义了 livenessProbe。 每 5 秒，探测器就会检测并执行该命令。 如果失败，将再次重新启动 pod。 准备状况健康检查配置文件。 apiVersion: v1 kind: Pod metadata: labels: test: readiness name: readiness spec: restartPolicy: OnFailure containers: - name: readiness image: busybox args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 60 readinessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 10 periodSeconds: 5 该文件类似于liveness。 刚刚更改了键值。 对于这一点，当失败时，会重新启动 pod 一次，之后，设置 readiness 就没有用了。 ","date":"2020-02-28 09:11:51","objectID":"https://yeliansong.github.io/2020-4-11-health-check/:0:1","tags":["K8S","微服务"],"title":"健康检查","uri":"https://yeliansong.github.io/2020-4-11-health-check/"},{"categories":["K8S-学习笔记"],"content":"2.滚动更新中的健康检查实践 健康检查如何运用在滚动更新中？ 想象一种情况，你将应用程序从V1更新到V2，但实际上V2应用程序是错误的，你没有使用检查方法来验证这一点。 你将如何解决这个问题？ 我们可以使用健康检查。 首先，使用 v1 部署 10 个副本。 apiVersion: apps/v1 kind: Deployment metadata: name: app spec: replicas: 10 selector: matchLabels: run: app template: metadata: labels: run: app spec: containers: - name: app image: busybox args: - /bin/sh - -c - sleep 10; touch /tmp/healthy; sleep 30000 readinessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 10 periodSeconds: 5 然后滚动更新错误的应用程序。 它将触发探测器进行检测。 apiVersion: apps/v1 kind: Deployment metadata: name: app spec: replicas: 10 selector: matchLabels: run: app template: metadata: labels: run: app spec: containers: - name: app image: busybox args: - /bin/sh - -c - sleep 3000 readinessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 10 periodSeconds: 5 使用此配置文件部署时，会失败。 下面是结果。 从结果中我们可以看到新的复制无法通过健康检查。 但健康检查仍然是最古老的复制。 这是因为 maxSurge 和 maxUnavailable。 如果文件中没有定义，则使用默认值。maxSurge 和 maxUnavailable 用于定义滚动更新副本和故障副本。 ","date":"2020-02-28 09:11:51","objectID":"https://yeliansong.github.io/2020-4-11-health-check/:0:2","tags":["K8S","微服务"],"title":"健康检查","uri":"https://yeliansong.github.io/2020-4-11-health-check/"},{"categories":["K8S-学习笔记"],"content":"3.滚动更新 此部分不用于健康检查。 只是之前学习的总结。 本节包括滚动更新和回滚。 滚动更新非常简单，只需运行命令，就会自动部署更改。 我们主要讨论回滚。 当您进行滚动更新时，您可以记录修订版本。 当您想要回滚时，可以定位到该版本。 Kuebctl apply -f rollback.yaml –record 当添加记录参数时，会记录回溯。 Kubectl 推出历史部署 http 这将显示所有部署历史版本。 Kubectl 推出撤消部署 http –to-revision=1 这将推出该版本。 此外，当您成功推出后，版本将随着您的部署而更改。 ","date":"2020-02-28 09:11:51","objectID":"https://yeliansong.github.io/2020-4-11-health-check/:0:3","tags":["K8S","微服务"],"title":"健康检查","uri":"https://yeliansong.github.io/2020-4-11-health-check/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2020-02-15 10:11:51","objectID":"https://yeliansong.github.io/2020-04-08-how-to-write-the-yaml/","tags":["K8S","微服务"],"title":"如何编写 YAML","uri":"https://yeliansong.github.io/2020-04-08-how-to-write-the-yaml/"},{"categories":["K8S-学习笔记"],"content":"1.如何编写YAML apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deploymnet spec: replicas: 3 selector: matchLabels: app: web_server template: metadata: labels: app: web_server spec: containers: - name: nginx image: nginx:1.7.9 好的，让我们分析一下这个 YAML 示例。 它使用缩进来表示图层。 每一层都是相互依赖、相互调用的。每个key的含义。 apiVersion：这是当前配置版本。 Kind：创建的资源类型。 元数据：资源元数据。 规格：部署的规格。 选择器：用于选择哪个模板。 模板：定义Pod信息。 所以，由此，我想我可以用思维导图来描述。我们可以参考下面。 ","date":"2020-02-15 10:11:51","objectID":"https://yeliansong.github.io/2020-04-08-how-to-write-the-yaml/:0:1","tags":["K8S","微服务"],"title":"如何编写 YAML","uri":"https://yeliansong.github.io/2020-04-08-how-to-write-the-yaml/"},{"categories":["K8S-学习笔记"],"content":"2. 如何编写作业配置文件 首先，我们需要确定工作的目标。 容器可以分为两种，一种是为服务器持久化运行，另一种是只运行一项作业，一次运行。 这就是工作。 如何定义作业配置文件。 apiVersion: batch/v1 kind: Job metadata: name: myjob spec: parallelism: 3 template: metadata: name: myJob spec: containers: - name: hello image: busybox command: [\"echo\", \"hello k8s job\" ] restartPolicy: OnFailure 实际上作业配置有很多种，包括常规作业、并行作业和定时作业。 还需要灵活使用restartPolicy参数。 OnFailure 表示失败时，将重新启动 pod。 您也可以设置“never”，这意味着将重新启动 pod，直到成功为止。 ","date":"2020-02-15 10:11:51","objectID":"https://yeliansong.github.io/2020-04-08-how-to-write-the-yaml/:0:2","tags":["K8S","微服务"],"title":"如何编写 YAML","uri":"https://yeliansong.github.io/2020-04-08-how-to-write-the-yaml/"},{"categories":["K8S-学习笔记"],"content":"3. YAML 总结 最后，我认为如果掌握了规则，YAML并不难。 它由层组成。 因此，如果您了解每一层，您就可以设计您的部署、作业或服务。 ","date":"2020-02-15 10:11:51","objectID":"https://yeliansong.github.io/2020-04-08-how-to-write-the-yaml/:0:3","tags":["K8S","微服务"],"title":"如何编写 YAML","uri":"https://yeliansong.github.io/2020-04-08-how-to-write-the-yaml/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2020-02-04 10:11:51","objectID":"https://yeliansong.github.io/2020-4-25-deployment/","tags":["K8S","微服务"],"title":"K8S部署","uri":"https://yeliansong.github.io/2020-4-25-deployment/"},{"categories":["K8S-学习笔记"],"content":"Deployment 为 Pod 和 ReplicaSet 提供声明性更新。 我们可以利用许多部署功能。 本章涵盖更新部署、回滚部署、调用部署、暂停和恢复部署和部署状态。 首先，我们创建一个部署。 apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deploymnet spec: replicas: 3 selector: matchLabels: app: web_server template: metadata: labels: app: web_server spec: containers: - name: nginx image: nginx:1.7.9 更新部署 参考此链接：[https://yeliansong.github.io/2020/04/22/K8S-Deployment-Strategies/](https://yeliansong.github.io/2020/04/22/K8S-Deployment- 策略/） 它涵盖了部署的推出和回滚。 缩放部署 您可以根据需要使用以下命令来扩展 Deployment。 kubectl scale deployment nginx-deploymnet --replicas=10 假设集群中启用了水平 Pod 自动缩放，您可以为 Deployment 设置自动缩放器，并根据现有 Pod 的 CPU 利用率选择要运行的最小和最大 Pod 数量。 kubectl autoscale deployment nginx-deploymnet --min=10 --max=15 --cpu-percent=20 暂停和恢复部署 您可以在触发一个或多个更新之前暂停部署，然后再恢复它。 这允许您在暂停和恢复之间应用多个修复，而不会触发不必要的推出。 kubectl rollout pause deployment nginx-deploymnet 这将暂停部署，然后您可以修补此部署的更改。 kubectl set image deployment nginx-deploymnet nginx=nginx:1.16.1 之后，您可以恢复部署。 kubectl rollout resume deployment nginx-deploymnet 部署状态 Deployment 在其生命周期中会进入各种状态。 它可以是正在进展、已完成或未进展。 当执行以下任务之一时，部署进入进度状态。 Deployment 创建一个新的 ReplicaSet Deployment 正在扩展其最新的 ReplicaSet Deployment 正在缩减其旧的 ReplicaSet 新 Pod 已准备就绪或可用 您可以使用 kubectl rollout status 来监控进度。 当具有以下特征时输入完整。 所有副本均已更新至您指定的最新版本。 所有副本均可用 部署的旧副本没有正在运行。 匹配失败的原因有以下一项。 配额不足 就绪探针故障 图像拉取错误 权限不足 限制范围 应用程序运行时配置错误 以下命令使用progressDeadlineSeconds 设置规范，以使控制器在您定义的时间之后报告部署缺乏进度。 Kubectl patch deployment nginx-deployment -p '{\"spec\":{\"progressDeadlineSeconds\":600}}' ","date":"2020-02-04 10:11:51","objectID":"https://yeliansong.github.io/2020-4-25-deployment/:0:0","tags":["K8S","微服务"],"title":"K8S部署","uri":"https://yeliansong.github.io/2020-4-25-deployment/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2020-01-25 09:11:51","objectID":"https://yeliansong.github.io/2020-4-14-volume/","tags":["K8S","微服务"],"title":"Volume","uri":"https://yeliansong.github.io/2020-4-14-volume/"},{"categories":["K8S-学习笔记"],"content":"1.emptyDir 这是卷的基础。 生命周期取决于Pod。 当相关 Pod 被删除时，该卷也会被删除。 所以我们可以将其视为Pod的路径。 Pod 的所有容器共享这个 voiume。 让我们展示如何设置音量配置。 apiVersion: v1 kind: Pod metadata: name: producer-consumer spec: containers: - image: busybox name: producer volumeMounts: - mountPath: /producer_dir name: shared-volume args: - /bin/sh - -c - echo \"hello world\" \u003e /producer_dir/hello; sleep 30000 - image: busybox name: consumer volumeMounts: - mountPath: /consumer_dir name: shared-volume args: - /bin/sh - -c - cat /consumer_dir/hello; sleep 30000 volumes: - name: shared-volume emptyDir: {} 上面的文件是关于配置卷的练习。 我们在pod中设计了两个容器，一个是生产者，将日志写入路径文件中，另一个是消费者，从文件中读取日志。 很容易理解，这两个容器共享 Pod 的存储。 ","date":"2020-01-25 09:11:51","objectID":"https://yeliansong.github.io/2020-4-14-volume/:0:1","tags":["K8S","微服务"],"title":"Volume","uri":"https://yeliansong.github.io/2020-4-14-volume/"},{"categories":["K8S-学习笔记"],"content":"2. 主机路径 这种体积很少使用。 这并不常见。 这用于 Docker 主机挂载 Pod 的现有路径。 所以Pod和容器有很强的耦合性。 但如果 pod 被删除，该卷仍然存在。 但是，请避免使用此类卷。 ","date":"2020-01-25 09:11:51","objectID":"https://yeliansong.github.io/2020-4-14-volume/:0:2","tags":["K8S","微服务"],"title":"Volume","uri":"https://yeliansong.github.io/2020-4-14-volume/"},{"categories":["K8S-学习笔记"],"content":"3. 外部存储提供商 这使用外部存储提供者来实现卷。 例如使用AWS，GCE或Azure等。 让我展示一下配置。 这使用了 aws 存储。 使用它的优点是使 k8s 集群和卷隔离。 k8s集群销毁时没有影响。 ","date":"2020-01-25 09:11:51","objectID":"https://yeliansong.github.io/2020-4-14-volume/:0:3","tags":["K8S","微服务"],"title":"Volume","uri":"https://yeliansong.github.io/2020-4-14-volume/"},{"categories":["K8S-学习笔记"],"content":"4.持久卷和持久卷声明 从第 3 节中，我们知道我们可以使用 k8s 卷的外部存储。 但有一个问题，实际上存储系统总是用于管理的，而k8s部署是用于开发人员的。 有不同的部门。 如何平衡差距。 解决方法是PV和PVC。 PV由管理部门维护，是安排的外部存储。 但PVC是给开发商用的。 部署微服务时，可以设置pvc来安排PV的空间。 因此PV和PVC协调部署整个系统。 4.1 NFS 持久卷 首先，在主从节点上安装NFS服务。 还定义安装路径。 以下是 PV 和 PVC 配置文件。 nfs-pv.yaml apiVersion: v1 kind: PersistentVolume metadata: name: mypv1 spec: capacity: storage: 1Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Recycle storageClassName: nfs nfs: path: /tmp/pv1 server: 10.128.0.2 nfs-pvc.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: mypvc1 spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi storageClassName: nfs pod.yaml apiVersion: v1 kind: Pod metadata: name: mypod1 spec: containers: - name: mypod1 image: busybox args: - /bin/sh - -c - sleep 30000 volumeMounts: - mountPath: \"/mydata\" name: mydata volumes: - name: mydata persistentVolumeClaim: claimName: mypvc1 在PV YAML文件中，我们可以定义持久卷策略类型。 有保留、回收、删除三种类型。默认策略是删除。 Retain：用户删除了一个perpetitiveVolumeClaim，对应的perpetitiveVolume并没有被删除。 相反，它已进入发布阶段，可以手动恢复其所有数据。 Recycle：与Retain不同，删除PVC后数据无法手动恢复。 删除：这是默认模式。 意味着当用户删除相应的图片时，动态pv会自动删除。 运行 pod 时，将挂载 PVC 路径。 然后使用命令向挂载路径写入一些内容。 从下面的运行结果，我们可以了解NFS中的PV和PVC。 关于是静态规定，还有另一种规定，它是动态规定。 它根据情况安排存储。 4.2 数据库实践 后台：使用NFS PV和PVC在节点关闭时进行数据库备份，以验证数据持久性。 步骤： 根据以下配置文件部署PV和PVC。 mysql-pvc.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: mysql-pvc spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi storageClassName: nfs mysql-pv.yaml apiVersion: v1 kind: PersistentVolume metadata: name: mysql-pv spec: accessModes: - ReadWriteOnce capacity: storage: 1Gi persistentVolumeReclaimPolicy: Retain storageClassName: nfs nfs: path: /tmp/mysql-pv server: 10.128.0.2 yaml 部署 mysql pod 和服务 piVersion: v1 kind: Service metadata: name: mysql spec: ports: - port: 3306 selector: app: mysql --- apiVersion: apps/v1 kind: Deployment metadata: name: mysql spec: selector: matchLabels: app: mysql template: metadata: labels: app: mysql spec: containers: - image: mysql:5.6 name: mysql env: - name: MYSQL_ROOT_PASSWORD value: password ports: - containerPort: 3306 name: mysql volumeMounts: - name: mysql-persistent-storage mountPath: /var/lib/mysql volumes: - name: mysql-persistent-storage persistentVolumeClaim: claimName: mysql-pvc 使用客户端访问数据库，向数据库中插入一些消息。 关闭node1，数据库会自动备份到node2。 备份完成后，我们可以在master节点进行验证 ","date":"2020-01-25 09:11:51","objectID":"https://yeliansong.github.io/2020-4-14-volume/:0:4","tags":["K8S","微服务"],"title":"Volume","uri":"https://yeliansong.github.io/2020-4-14-volume/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2020-01-04 09:11:51","objectID":"https://yeliansong.github.io/2020-3-22-understand-the-k8s-architecture/","tags":["K8S","微服务"],"title":"了解K8S架构","uri":"https://yeliansong.github.io/2020-3-22-understand-the-k8s-architecture/"},{"categories":["K8S-学习笔记"],"content":"1.k8s组件架构。 好吧，这很容易理解。 如上所述，主节点是最重要的。 它控制其他节点加入集群。 API服务器也暴露在外。 通过主节点，即可安排其他节点。 ","date":"2020-01-04 09:11:51","objectID":"https://yeliansong.github.io/2020-3-22-understand-the-k8s-architecture/:0:1","tags":["K8S","微服务"],"title":"了解K8S架构","uri":"https://yeliansong.github.io/2020-3-22-understand-the-k8s-architecture/"},{"categories":["K8S-学习笔记"],"content":"2.实例操练 目标：创建k8s集群，然后将应用程序部署到这2个节点。 步骤： 使用kubeadm init创建主k8s集群，然后将node1和node2加入集群。 在主节点中，部署应用程序，复制数为2。 执行后，部署完成。 您可以执行命令“kubectl get pods”，显示部署情况。 该应用程序分别部署在2个节点中。 ","date":"2020-01-04 09:11:51","objectID":"https://yeliansong.github.io/2020-3-22-understand-the-k8s-architecture/:0:2","tags":["K8S","微服务"],"title":"了解K8S架构","uri":"https://yeliansong.github.io/2020-3-22-understand-the-k8s-architecture/"},{"categories":["K8S-学习笔记"],"content":"3.了解流程 这就是整个过程。 当执行“kubectl run”时，会调用API Server，然后API Server通知Controller Server创建部署资源。 之后Schedule服务会将任务安排到node1和node2上。 在node1和node2中，kubelet会根据任务创建pod。 Kube-proxy 将为这 2 个节点安排网络配置。 ","date":"2020-01-04 09:11:51","objectID":"https://yeliansong.github.io/2020-3-22-understand-the-k8s-architecture/:0:3","tags":["K8S","微服务"],"title":"了解K8S架构","uri":"https://yeliansong.github.io/2020-3-22-understand-the-k8s-architecture/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2019-11-01 15:11:51","objectID":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/","tags":["K8S","微服务"],"title":"九、Deployment声明式升级应用","uri":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"1. 升级的几种方式 先来看一个案例，这种情况怎么处理： POD现在用的是V1版本，现在有一个V2版本，怎么把V2版本替换到V1版本？有三种方式： 删除旧版本POD，是用新版本POD替换 这种方法比较暴力，就是直接修改V1的配置模板为V2，然后删除V1的POD，这个时候V2的模板会检测，没有POD，会重新启动V2 版本的POD。这种方法会有一个问题，删除V1时整个服务会停止。 蓝绿部署 这个是这样的，就是你的程序同时支持V1，V2 版本，同时你的环境资源充分，可以同时运行这两个， 怎么做呢？ 就是在你的环境里把V2的POD启动起来，待所有的完全都没问题后，可以删除掉V1的POD，把服务的流量切换到V2。 这种方式的问题就是资源开销较大。 滚动升级 这个就比较厉害了，它是利用扩容和缩容来实现动态替换升级。 啥意思呢，就是在你的部署文件中定义新旧版本的POD，然后依次删除V1的POD， 使V2 的POD动态扩容。但是这种方式，如果用命令来操作比较繁琐。 ","date":"2019-11-01 15:11:51","objectID":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/:0:1","tags":["K8S","微服务"],"title":"九、Deployment声明式升级应用","uri":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"2. 使用ReplicationController 实现自动滚动升级 使用kubectl 命令方式进行滚动升级。kubectl rolling-update kubia-v1 kubia-v2 –image=luksa/kubia:v2 命令。 这个命令到底干了啥呢，来看看。 可以看看这个图，是通过修改Replicas的数量来慢慢替换V1 的POD为V2。 但是这种方式有个问题，因为是用的Kubectl方式来完成这些，相当于是客户端方式，所以，如果没有网络时，可能会导致升级停止。 ","date":"2019-11-01 15:11:51","objectID":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/:0:2","tags":["K8S","微服务"],"title":"九、Deployment声明式升级应用","uri":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"3. 使用Deployment升级应用 Deployment 是一种更加高级的升级方式，它是属于上层的一种升级方式，而另外几种是属于底层的。 使用Deployment时，实际是用的ReplicaSet来管理POD。所以到底是怎么做到滚动升级的呢。 Deployment 就是一个部署文件，可以在里面定义你要部署的信息，然后进行部署。 定义了一个部署，现在来看看如何来实现滚动升级。首先要触发升级，怎么触发呢，通过修改Deployment 文件的方式来触发。可以用Kubectl set image deployment kubia nodejs=luksa/kubia:v2 来重新指定镜像，POD就会重新去下载镜像。 然后在内部，它会依次去删除掉V1 的POD，然后再启动V2的POD。 它也可以自己定义升级的策略，RollinUpdate和Recreate两种，默认是第一种。 ","date":"2019-11-01 15:11:51","objectID":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/:0:3","tags":["K8S","微服务"],"title":"九、Deployment声明式升级应用","uri":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"4. 回滚升级 现在有一个问题啊，假如你要升级一个V3版本，但是呢，V3 版本有一些bug,你升级了，然后发现有问题了，怎么回退到之前的版本呢？可以用命令方式解决：kubectl rollout undo deployment kubia， 可以回滚到上一个版本。也可以回退到某一个历史版本，可以先查看历史：kubectl rollout history deployment kubia 看所有的历史版本， 然后用kubectl rollout undo deployment kubia –to-revision = ? 来回退到某一个版本。 ","date":"2019-11-01 15:11:51","objectID":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/:0:4","tags":["K8S","微服务"],"title":"九、Deployment声明式升级应用","uri":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"5. 滚动升级的状态控制 控制升级速率 用两个参数来定义：maxSurge 和 maxUnavailable ， 具体怎么计算的我不太想搞清楚了，可以看看作用。 暂停滚动升级 这个可以用来玩金丝雀升级。啥叫金丝雀，就是被束缚的。怎么玩呢，就是先来搞个滚动升级，然后立即暂停滚动升级，这个时候新的POD会被创建，旧的POD还在运行，而流量会有一部分切换到新的POD中，然后测试，测试通过后，你可以恢复滚动升级，完成替换，如果测试没有通过，可以回滚到之前版本。金丝雀升级其实就是让一些人来体验新版本。看看命令： kubectl rollout pause deployment kubia kubectl rollout resume deployment kubia 阻止出错版本的滚动升级 还有一个比较好的方式，就是可以设置一个时间段，和设置探针，在这个时间段呢，如果新的POD没有问题，则就支持滚动升级。这个相当于设置了一个保险，可以将风险降到最低。 为滚动升级配置的deadline 就是设置一个时间段，如果程序没有升级成功，就可以取消升级。 ","date":"2019-11-01 15:11:51","objectID":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/:0:5","tags":["K8S","微服务"],"title":"九、Deployment声明式升级应用","uri":"https://yeliansong.github.io/2019-09-16-9-deployment%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%8D%87%E7%BA%A7%E5%BA%94%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2019-10-12 15:11:51","objectID":"https://yeliansong.github.io/2019-09-16-8-%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/","tags":["K8S","微服务"],"title":"八、从应用访问POD元数据及其他资源","uri":"https://yeliansong.github.io/2019-09-16-8-%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/"},{"categories":["K8S-学习笔记"],"content":"1. Downward API传递元数据 说实话，这章看的也是云里雾里的，感觉和环境变量配置差不多。我的理解是，Downward API 是用来给POD或容器的元数据进行配置，环境变量呢，是用来定义一些常规的变量参数。Downward API支持环境变量和文件两种方式，更加灵活。 ","date":"2019-10-12 15:11:51","objectID":"https://yeliansong.github.io/2019-09-16-8-%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/:0:1","tags":["K8S","微服务"],"title":"八、从应用访问POD元数据及其他资源","uri":"https://yeliansong.github.io/2019-09-16-8-%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/"},{"categories":["K8S-学习笔记"],"content":"2. Kubernetes API 服务器交互 其实这一节主要就是讲，怎么使用Kubernetes 的API 。使用API其实就是访问它的服务器。每一层目录就是一级资源。 这个是通过ambassador 容器方式来访问API服务器。当然，也可以通过客户端的方式来访问API服务器。这一章内容主要是来配置POD的元数据，同时通过API方式来访问资源。 ","date":"2019-10-12 15:11:51","objectID":"https://yeliansong.github.io/2019-09-16-8-%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/:0:2","tags":["K8S","微服务"],"title":"八、从应用访问POD元数据及其他资源","uri":"https://yeliansong.github.io/2019-09-16-8-%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2019-10-10 14:11:51","objectID":"https://yeliansong.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","tags":["K8S","微服务"],"title":"七、ConfigMap 和 Secret配置应用程序","uri":"https://yeliansong.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":["K8S-学习笔记"],"content":"1. 容器命令行参数的配置 Docker 使用命令行参数是通过在Dockerfile 中定义Entrypoint 和CMD来实现，但是有个问题啊，这个是打包到镜像里的。先来看看这两个的区别吧。 Entrypoint: 定义容器启动时被调用的可执行程序。 CMD：指定传递给Entrypoint 的参数。 所以常规做法还是定义这两个，用命令行启动时，可以通过命令行的argu来覆盖file中的CMD的定义。当然了还有一种方式，就是脚本方式，可以将命令写入到脚本中，然后在dockerfile中定义调用这个脚本。 POD 中定义的命令可以覆盖容器的命令行。所以可以通过POD的YAML文件中的argu将参数传递给容器。 ","date":"2019-10-10 14:11:51","objectID":"https://yeliansong.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:1","tags":["K8S","微服务"],"title":"七、ConfigMap 和 Secret配置应用程序","uri":"https://yeliansong.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":["K8S-学习笔记"],"content":"2. POD 环境变量的常规操作 在引出ConfigMap 之前，来看看POD配置环境变量的常规操作。其实你要明白，环境变量是给容器用的，所以呢一种思路就是这样的，在容器中定义好环境变量，容器里的程序引用环境变量，然后在POD的配置文件中对环境变量进行赋值，这就是常规操作。 就像这样的，定义了一个环境变量，然后呢，在POD中对这个变量进行赋值。这个方法呢，怎么样，好吗？显然是不好的，没有解耦，就是环境变量和POD的配置文件强相关了，所以有没好的方法可以实现解耦呢，就是这个配置文件不仅在这里可以用，在其他地方也可以用。这就使用ConfigMap 了。 ","date":"2019-10-10 14:11:51","objectID":"https://yeliansong.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:2","tags":["K8S","微服务"],"title":"七、ConfigMap 和 Secret配置应用程序","uri":"https://yeliansong.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":["K8S-学习笔记"],"content":"3. ConfigMap 先要理解它要解决的问题，其实就是相当于一个独立的配置文件，然后可以在不同的环境里来引用它。所以这个东西还是蛮好的。创建ConfigMap可以通过命令方式或者YAML文件。不详细讲怎么创建了。 这个例子是，利用POD对容器中的环境变量INTERVAL进行重写。基本过程就是这样的： 不解释了，清楚明了。 但是有个问题啊，如果这个配置文件不存在怎么办，这个POD还能起来吗，答案是否定的。它会一直等存在这个配置文件后，容器才能启动。当然，你也可以设置参数，使其如果没有配置文件也能启动POD。 当然如果你的config file包含很多的key-value，一个一个设置，麻烦，可以一步到位。 prefix 是用来设置前缀的，还有一个，在配置文件中设置的key-value一定要按照格式来，不然的话，Kubernetes 不能解析。 ","date":"2019-10-10 14:11:51","objectID":"https://yeliansong.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:3","tags":["K8S","微服务"],"title":"七、ConfigMap 和 Secret配置应用程序","uri":"https://yeliansong.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":["K8S-学习笔记"],"content":"4. secert 配置文件 当然，配置文件不能都是名文，对于需要进行加密的需要用secert方式进行配置。secert 和configMap一样也是key - value 方式，但是还是有一些区别，secert 是存在于POD的内存中，所以当删除POD时，就没有了这个配置。 ","date":"2019-10-10 14:11:51","objectID":"https://yeliansong.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:4","tags":["K8S","微服务"],"title":"七、ConfigMap 和 Secret配置应用程序","uri":"https://yeliansong.github.io/2019-09-13-7-configmap-%E5%92%8C-secret%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2019-10-03 14:11:51","objectID":"https://yeliansong.github.io/2019-09-12-6-%E5%8D%B7-%E5%B0%86%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8/","tags":["K8S","微服务"],"title":"六、卷-将磁盘挂载到容器","uri":"https://yeliansong.github.io/2019-09-12-6-%E5%8D%B7-%E5%B0%86%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8/"},{"categories":["K8S-学习笔记"],"content":"1. 卷（volume） 终于等到你了，卷，volume。 也是kubernetes很重要的一个组件啊。不对，应该不能说是k8s的一个组件，应该说是属于POD中的一个组成部分。 卷是用来解决什么问题呢？POD其实相当于一个逻辑主机，每个POD可能有多个容器，这些容器呢，我们知道其实就相当于逻辑主机的进程，这些进程可以共享CPU，RAM，网络等，但是呢，每个容器是由自己的文件系统的，这些系统是相互隔离的，有没办法让这些容器共享文件系统呢？你想这个场景，比如POD里的一个容器挂了，然后重新起一个，但是起的这个呢依旧用之前那个的文件系统资源，怎么解决这个问题，你必须要用卷吗，相当于用共享的这个文件系统。 看这个，一个POD里面跑了三个容器，每个都是独立的文件系统，你说这个能跑起来吗？我来介绍下这三个容器，webserver， 就是web的入口，content用来放网页信息，log来存放日志，这三个没有共享文件系统，访问时web容器都找不到网页，日志也存放不了。来，看看改进版本。 共享卷之后，哈哈哈，能跑了，爽不爽。 ","date":"2019-10-03 14:11:51","objectID":"https://yeliansong.github.io/2019-09-12-6-%E5%8D%B7-%E5%B0%86%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8/:0:1","tags":["K8S","微服务"],"title":"六、卷-将磁盘挂载到容器","uri":"https://yeliansong.github.io/2019-09-12-6-%E5%8D%B7-%E5%B0%86%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8/"},{"categories":["K8S-学习笔记"],"content":"2. 卷的几种类型 卷其实还是一种存储介质，它用的是宿主机，也就是POD主机的存储媒介。所以卷的性能是受逻辑主机影响的，当然也可以设置卷用memory的存储。根据使用习惯呢，卷也有很多类型。介绍两种： emptyDir 也是最简单的卷类型了，也是其他卷的基础，很好理解了，就是空卷。它的生命周期是和POD的生命周期一致的。这个是在POD启动时，会初始化一块空白的空间来存储内容。 这个就是例子了，每一个image可以设置卷的路径，然后在volume节点上可以设置卷的类型。 这个可以定义是用内存还是用的存储媒介。 Git存储卷 这个卷也是特别有意思，就是为git仓库设计的， 这个就是模型图了，POD启动时，会把远程的git 仓库拉到这个volume中，但是这个是不能实时同步的，也理解了，不会有这么先进的。 GIT 卷的原形是empty 卷，所以，生命周期也是和POD保持一致。 ![1568261085518]( HostPath 卷 POD 之间能否共享文件呢，能的，这就是HostPath 卷。 你看这个图，两个POD 共享这个HostPath卷，所以即使你删除一个POD也不会对这个卷有影响。但是有一个问题，这个卷是和POD强相关的，就是如果你用其他的POD，就不能访问这个卷了。 持久卷 这一部分是很不同的环境相配合的，如果你用的是GCP，则有相应的组件支持，其他的云平台，也有其他的相应组件。所以这部分也不讲了，要弄清楚它的使用场景，这个是需要对数据进行持久化的，就是可以跨不同的节点进行数据访问。后续有用到可以着重看看。 ","date":"2019-10-03 14:11:51","objectID":"https://yeliansong.github.io/2019-09-12-6-%E5%8D%B7-%E5%B0%86%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8/:0:2","tags":["K8S","微服务"],"title":"六、卷-将磁盘挂载到容器","uri":"https://yeliansong.github.io/2019-09-12-6-%E5%8D%B7-%E5%B0%86%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2019-10-01 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/","tags":["K8S","微服务"],"title":"五、POD的服务与通信","uri":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":["K8S-学习笔记"],"content":"1. 服务与端口 服务其实很好理解了，你想想看，一组相同的POD，你怎么管理，你需要知道他们的所有IP吗，然后再去一一进行手动配置连接？显然不需要的，怎么解决这个问题呢，就用服务，服务其实就是相当于一个路由的功能。 看看这个，前端有3个POD，还有一个Backend，怎么使整个系统正常运行呢，使用服务。三个前端设置一个前端服务，暴露一个IP，Backend也一样，暴露一个服务，所以每一部分的连接就只关注这个服务IP，而不用管每个POD的网络信息了。 ![1568172261841]( 这个是创建服务的YAML，KIND是一个Service， 然后将POD的端口进行映射，还有一个标签选择器。可以用kubectl expose 或 kubectl create 来创建服务。 这个好玩吗， 就是通过服务的方式来测试是否可以访问POD。就是先exec到一个POD中，然后通过curl方式来访问这个服务的ip，看能否连接到其他的POD。 很简单了。 来说说端口，一个POD可以有一个端口，也可以有多个端口，好理解了。 ","date":"2019-10-01 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/:0:1","tags":["K8S","微服务"],"title":"五、POD的服务与通信","uri":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":["K8S-学习笔记"],"content":"2. 服务发现 其实就是用环境变量的方式来连接这个服务，而不是用固定IP的方式，毕竟IP可能会有变化。 可以选择一个POD，然后kubectl exec kubia-3inly env 来列出环境变量，然后查看这个服务的环境变量，通过变量的方式供给其他客户端连接。 ","date":"2019-10-01 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/:0:2","tags":["K8S","微服务"],"title":"五、POD的服务与通信","uri":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":["K8S-学习笔记"],"content":"3. Endpoint 这家伙比较有意思了。看图吧。 很清晰明了，相当于把服务映射到了两个Endpoint中，可以理解为是负载均衡吗，有点像。 ","date":"2019-10-01 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/:0:3","tags":["K8S","微服务"],"title":"五、POD的服务与通信","uri":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":["K8S-学习笔记"],"content":"4. 服务暴露给外部客户端的方法 记住了，三种方法。 NodePort 不知道这个设置的意义，啥意思呢，就是相当于给所有的节点预留了一个PORT，然后呢你有两种途径来访问它。第一种是clusterIp:端口，第二种是nodeIp：端口 有三个端口号，第一个是服务集群的端口，第二个是POD的目标端口，第三个是nodePort端口。!这个图可以看到，30123是nodeport的端口，通过这个端口加node的IP可以访问节点。 负载均衡方式 它是从云基础架构中，搞一个外部IP，这个IP是独一无二的可公开访问的IP地址，通过这个再重定向到服务。其他的感觉没啥说的，看这个吧。 这个负载均衡器可以平均流量，看看它的策略。 ingress 一图看清它的功能： 啥意思呢，就是说可以通过域名的方式来选择性的访问服务。 ![1568195964547](这张图是看通过ingress方式来访问POD。 ","date":"2019-10-01 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/:0:4","tags":["K8S","微服务"],"title":"五、POD的服务与通信","uri":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":["K8S-学习笔记"],"content":"5. 就绪探针 又他妈的一个神奇东西。真的是要处理各种情况，就绪探针是用来处理这种情况，就是你启动一个POD，不可能立即马上就起来吧，但是kube不知道啊，它可能还是会把流量可能给你啊，所以怎么避免这个问题呢，就用到了就绪指针，就是说，设置一个指针，成功或失败了都通知kube。 设置了一个就绪指针，就是在容器中执行ls命令，看文件存不存在。 ","date":"2019-10-01 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/:0:5","tags":["K8S","微服务"],"title":"五、POD的服务与通信","uri":"https://yeliansong.github.io/2019-09-11-5-pod%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%80%9A%E4%BF%A1/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2019-09-17 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/","tags":["K8S","微服务"],"title":"四、副本机制部署托管POD","uri":"https://yeliansong.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/"},{"categories":["K8S-学习笔记"],"content":"1. 存活探针 为啥要搞出这么一个高深的词？我们知道POD里如果有容器程序崩溃了，kubenetes 会重新启动程序，但是问题来了，如果不是崩溃的情况呢，比如死锁了，或者抛了异常等等，这个时候咋整，kubenetes也不知道你的容器是否正常，这个时候就要用到探针了。其实道理很简单，就是用一个探针时不时地探测下，看是否正常。 三种探针：1）HTTP GET探针，就是用来检查网络是否正常。2）TCP套接字探针，也差不多，就是建立TCP连接，如果成功了就是正常的。3）Exec探针，就是在容器内执行任意命令，如果返回正常就是成功的。 探针其实也是一个POD，可以定义一些属性，用来控制探针的一些操作。 ","date":"2019-09-17 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/:0:1","tags":["K8S","微服务"],"title":"四、副本机制部署托管POD","uri":"https://yeliansong.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/"},{"categories":["K8S-学习笔记"],"content":"2. ReplicationController 也是一个很牛逼得东西，就是副本控制吧。就是用来保证POD的个数，可用来POD的水平扩展。 RC 有三个部分：label selector,标签选择器，用来确定RC作用域有哪些POD； RC COUNT：用来指定POD的数量； POD TEMP：模板，创建新POD副本。 来看看标签对RC的影响。其实也很好理解，RC只对它里面定义的标签负责，时刻监控着这些标签的POD个数，当这些标签的POD有减少或增加时，会动态调整。所以呢，两种情况，第一种，如果你修改了运行的POD里的标签，相当于这个POD以前是属于A，然后后面属于B了，这个时候RC要干事了，他会重新来创建POD。第二种情况，修改RC的标签，那这个标签里的POD全部脱离监控，全部都是自由的。 是用kubectl edit rc kubia 玩玩，你会发现，你可以修改当前的RC，然后修改当前的RC对现在运行的POD是没有任何影响的，只会对后面的POD有影响。 有点意思，三个POD，删除RC后，这3个POD不受影响，脱离了RC的束缚。 but， 不要用RC了，用ReplicaSet, 这哥们的功能和RC一样，但是功能增强了很多，主要是对标签的运用上更加灵活，其他的和RC完全一样，所以对这个也不要有压力了。 ","date":"2019-09-17 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/:0:2","tags":["K8S","微服务"],"title":"四、副本机制部署托管POD","uri":"https://yeliansong.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/"},{"categories":["K8S-学习笔记"],"content":"3. DaemonSet 这个又是用来干啥的呢，是用来控制POD的部署，意思就是按照自己的定义来部署POD。 来来来，看这货，左边是用的ReplicaSet，部署的POD在每个节点上是杂乱无章的，我现在要求每个节点只部署一个POD，这种情况怎么处理？这就要用到DaemonSet了。 这个时DaemonSet的YAML 文件，nodeSelector 节点调度器。 ","date":"2019-09-17 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/:0:3","tags":["K8S","微服务"],"title":"四、副本机制部署托管POD","uri":"https://yeliansong.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/"},{"categories":["K8S-学习笔记"],"content":"4. JOB 这个是用来定义一次任务，就是在完成后结束掉。而不是希望一直在运行它，这个也是一个很好的运用。JOB也有很多应用设置，可以设置任务的延迟时间等。 ","date":"2019-09-17 11:11:51","objectID":"https://yeliansong.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/:0:4","tags":["K8S","微服务"],"title":"四、副本机制部署托管POD","uri":"https://yeliansong.github.io/2019-09-11-4-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E9%83%A8%E7%BD%B2%E6%89%98%E7%AE%A1pod/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2019-09-15 11:16:51","objectID":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/","tags":["K8S","微服务"],"title":"三、运行于Kubernetes中的容器","uri":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["K8S-学习笔记"],"content":"1. 为啥要搞出POD 我们知道，POD是Kubernetes管理的最小单位，为啥Kubernetes不直接管理container，要管理POD呢？这是有原因的，我们知道，container是单一进程的，啥意思呢，就是container的设计思想就是每个container只运行一个进程， 如果用枯bernetes直接去管理这些container，肯定是错综复杂，所以就搞出了POD这个东西，来实现容器间的资源和网络隔离，在同一个POD下的所有容器共享网络和系统资源，但是呢，一个POD内的所有容器肯定是逻辑业务密切结合的一个整体，他们肯定是有很强的联系。每一个container可以用端口来进行区分。 ","date":"2019-09-15 11:16:51","objectID":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/:0:1","tags":["K8S","微服务"],"title":"三、运行于Kubernetes中的容器","uri":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["K8S-学习笔记"],"content":"2. 怎么规划POD中的容器 刚说到，POD中放的是一组容器，怎么来规划这些容器呢，把项目中所有容器都放到一个POD中可以吗？因为POD比较轻量，所以鼓励是尽可能多的用POD，而规划POD中的容器，需要考虑的是，你的这一组容器的业务逻辑是否紧密相连，还有你是否要scale你的容器，这些是你的判断条件。 很好的一个例子，前端和后端分为两个POD来进行部署。 ","date":"2019-09-15 11:16:51","objectID":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/:0:2","tags":["K8S","微服务"],"title":"三、运行于Kubernetes中的容器","uri":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["K8S-学习笔记"],"content":"3. YAML文件分析及创建POD 非常的EASY， 其实一个YAML文件就包含：kind, metadata, spe这些东西。metadata 是用来定义POD的数据，spec是用来定义这个POD下的所有容器数据。 有几个命令需要学习下：Kubectl create -f a.yaml， 这个是通过yaml文件来创建需要的POD。获取POD中指定容器的日志信息，可以用kubectl logs kula -c kubia。获取运行的POD的yaml或json格式文件，可以用kubectl get po kubia -o yaml 或kubectl get po kubia -o json。kubectl port-forward kubela 8888:8080 用来搞端口映射。 ","date":"2019-09-15 11:16:51","objectID":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/:0:3","tags":["K8S","微服务"],"title":"三、运行于Kubernetes中的容器","uri":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["K8S-学习笔记"],"content":"4. POD的标签 标签的作用毋庸置疑，就是用来区分POD。所以加入标签这个就是为了能更好的管理你的POD。一个POD可以设置多个标签，然后利用标签来统一的调度POD。标签的一些命令可以通过手册查看，包括修改标签，设置标签，增加标签等等。 ","date":"2019-09-15 11:16:51","objectID":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/:0:4","tags":["K8S","微服务"],"title":"三、运行于Kubernetes中的容器","uri":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["K8S-学习笔记"],"content":"5. Namespace 先搞清楚，搞出Namespace的目的，我们知道，已经有了标签的概念了，标签也是可以用来分组，但是为啥还是要搞出Namespace呢？标签的分组还是不太彻底，一个POD可以有多个标签，所以我觉得标签还是更多的给运维人员用，搞出Namespace就不一样了，每一个POD只有唯一的一个Namespace，使资源的分组更加的彻底。 来看看怎么玩Namespace。 kubectl get ns: 列出所有的命名空间，kubectl get po –namespace kube-system:列出指定Namespace的所有POD。kubectl create namespace custom-namespace,创建一个Namespace。 ","date":"2019-09-15 11:16:51","objectID":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/:0:5","tags":["K8S","微服务"],"title":"三、运行于Kubernetes中的容器","uri":"https://yeliansong.github.io/2019-09-10-3-%E8%BF%90%E8%A1%8C%E4%BA%8Ekubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2019-09-11 19:16:51","objectID":"https://yeliansong.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":["K8S","微服务"],"title":"二、Kubernetes 和 Docker的使用","uri":"https://yeliansong.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"1. 理解Docker镜像,文件系统和容器 容器的镜像就是打包编译容器后的一个文件，打包镜像是依赖Dockerfile文件，From行定义了镜像的起始内容，也就是构建的基础镜像，镜像的构建过程是将整个目录的文件上传到Docker守护进程中，Docker会先从基础镜像仓库中拉取基础镜像，然后镜像的打包是一个分层的结构，基础镜像作为一层，然后每一条命令会作为一个新的分层，一层一层叠加，整个就是一个联合文件系统。 容器的理解， 容器其实就是镜像运行的一个实例。容器是依赖于主机的操作系统运行的，所以就会有一个问题，比如在RedHat宿主机上打包的一个镜像，这个镜像能否在ubuntu上运行呢？不一定，要看你是否有用到宿主机特有的， 但是你在另外一个宿主机上运行没有的东西。镜像运行出的容器，相当于宿主机的一个进程。每个容器间的文件系统也是独立的。 ","date":"2019-09-11 19:16:51","objectID":"https://yeliansong.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/:0:1","tags":["K8S","微服务"],"title":"二、Kubernetes 和 Docker的使用","uri":"https://yeliansong.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"2. Kubernetes 集群和Mini Kube 先来理解下集群的概念，什么是集群？ 集群就是将多个计算机节点组合到一起，形成一个群集，所以集群的优点也很明显，可以更好的管理系统，提供单机系统的性能。 看看mini kube, 它是本地的一个单节点的集群，它不适用于多节点的情况。要想和kubernetes交互，还需要kubernetes cli客户端。 多节点的Kubernetes集群概览： 三个节点的kubernetes图。看看这个玩意， 每一个工作节点都有Docker，Kubelet和Kube-proxy,可以通过kubectl通过rest向主节点发送控制命令，来控制每个分节点。有意思。 ","date":"2019-09-11 19:16:51","objectID":"https://yeliansong.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/:0:2","tags":["K8S","微服务"],"title":"二、Kubernetes 和 Docker的使用","uri":"https://yeliansong.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"3. ReplicationControler POD 是Kubernetes 控制的最小单位，Kubernetes不会关心容器的调度，它只会管POD。一个POD中可以有很多个container，但是这一组container是关联密切的，因为他们可以看作是运行在同一个宿主机上。So 什么是ReplicationControler呢，这玩意是用来干啥的。 我的理解阿，ReplicationControler 是用来管理POD的水平伸缩，能够确保规定的POD个数能按照设置的正常运行。 可以看下这张图，外部访问过来后，只会映射到一个内部ip，然后到底调用的哪个POD我们是不用关心的，里面的每个POD都是独立的ip。ReplicationControler来控制副本的个数。 ","date":"2019-09-11 19:16:51","objectID":"https://yeliansong.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/:0:3","tags":["K8S","微服务"],"title":"二、Kubernetes 和 Docker的使用","uri":"https://yeliansong.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"4. 梳理下kubectl一些相关的命令 kubectl get pods, 列出所有的POD， kubectl expose kubia –type=LoadBalancer –name kubia-http.将服务的网络设置为LoadBalancer方式，kubectl get service,列出所有的服务 kubectl get replicationcontrollers,列出所有的副本。kubectl scale rc kubia –replicas=3,将副本扩充。 kubectl get rc,查看扩容。kubectl get pods -o wide,查看POD的ip和运行的节点。kubectl describe pod,可以查看这个POD的日志信息。 ","date":"2019-09-11 19:16:51","objectID":"https://yeliansong.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/:0:4","tags":["K8S","微服务"],"title":"二、Kubernetes 和 Docker的使用","uri":"https://yeliansong.github.io/2019-09-10-2-kubernetes-%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["K8S-学习笔记"],"content":"K8S学习的读书笔记","date":"2019-09-10 21:56:51","objectID":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/","tags":["K8S","微服务"],"title":"一、Kubernetes的介绍","uri":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"1. 单体应用和微服务的比较 单体应用的弊端：以单进程或几个进程的方式运行于几台服务器，部署的周期长，运维和开发脱节，开发人员完成开发后打包成一个整体给运维部署。 模块间没有解耦，修改一个模块，要把整体进行打包部署。 微服务的优势：模块间实现解耦，缩短部署周期，单个模块可以实现独立的开发，部署，升级，伸缩。缩短部署时间。还有节约资源，模块间可以单独 的进行扩容，而不用扩容所有。 ","date":"2019-09-10 21:56:51","objectID":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:1","tags":["K8S","微服务"],"title":"一、Kubernetes的介绍","uri":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"2. DevOps 微服务带来了DevOps。 以前的团队组合是，开发人员完成开发后把成果物给运维，然后运维完成部署，开发和运维是完全分开的。这就带来一个问题，开发人员不能第一时间了解用户的需求，而且也不了解系统的运行环境，而运维也不了解产品的功能。微服务来了后，通过kubernetes对系统硬件资源的虚拟化，使开发人员不用担心部署环境，简化系统的部署，开发人员也可以参与到部署中，也就衍生了DevOps。 ","date":"2019-09-10 21:56:51","objectID":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:2","tags":["K8S","微服务"],"title":"一、Kubernetes的介绍","uri":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"3. 容器技术 容器技术其实就是Linux的隔离技术。通过什么来进行隔离呢？ 命名空间和CGROUP。 命名空间是用来隔离不同的进程，CGROUP是用来隔离资源。就是通过这个能够使一个宿主机可以运行多个不同的应用程序。同一个宿主机上的两个应用程序也可以共享文件，如果共用同一个基本镜像，就是共用资源，但是 这一层文件是只读的，如果重写写入，是在基本镜像基础上写入一层文件，容器是用的联合文件系统。 ","date":"2019-09-10 21:56:51","objectID":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:3","tags":["K8S","微服务"],"title":"一、Kubernetes的介绍","uri":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"4. 容器的移植 容器的镜像是一个完整的系统，经过裁减后的。它裁减的还是宿主机的，所以一个容器镜像能否运行还是要看镜像所在运行的环境。如果编排镜像的宿主机环境的内核版本和运行环境一致，则可以运行。同时也要看是否用到宿主机特有的一些系统资源。 ","date":"2019-09-10 21:56:51","objectID":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:4","tags":["K8S","微服务"],"title":"一、Kubernetes的介绍","uri":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"5. Kubernetes Google搞出这个东西，是为了解决Google成千上万服务器的管理部署问题。之后容器技术火后，Kubernetes对容器的支持，所以说也可以说是Kubernetes成就了Docker。相符相承吧。Kubernetes的设计宗旨是将底层基础设施进行抽象化，通过给你提供一个主节点，来管理成千上万的你的服务的运行节点。你不用 关心你的服务运行节点的部署。 ","date":"2019-09-10 21:56:51","objectID":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:5","tags":["K8S","微服务"],"title":"一、Kubernetes的介绍","uri":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S-学习笔记"],"content":"6. Kubernetes 的组成 主节点： API服务器（功能入口，管理其他模块）， Schedule（调度应用）， Control Manager， etcd（分布式数据存储） 工作节点： kubelet (与API进行通信，管理容器)， kube-proxy(负责网络流量均衡) ","date":"2019-09-10 21:56:51","objectID":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/:0:6","tags":["K8S","微服务"],"title":"一、Kubernetes的介绍","uri":"https://yeliansong.github.io/2019-09-10-1%E4%B8%80kubernetes%E7%9A%84%E4%BB%8B%E7%BB%8D/"},{"categories":[],"content":"目前情况 ","date":"0001-01-01 00:00:00","objectID":"https://yeliansong.github.io/about/:0:1","tags":[],"title":"About","uri":"https://yeliansong.github.io/about/"},{"categories":[],"content":"工作经历 ","date":"0001-01-01 00:00:00","objectID":"https://yeliansong.github.io/about/:0:2","tags":[],"title":"About","uri":"https://yeliansong.github.io/about/"},{"categories":[],"content":"教育经历 ","date":"0001-01-01 00:00:00","objectID":"https://yeliansong.github.io/about/:0:3","tags":[],"title":"About","uri":"https://yeliansong.github.io/about/"}]